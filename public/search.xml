<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java回顾总结]]></title>
    <url>%2F2020%2F02%2F25%2Fjava-summary%2F</url>
    <content type="text"><![CDATA[Java回顾总结最近重温Java，做出总结，本文共分为语法细节、语法特点、接口&amp;抽象类、版本变化、内部类、集合框架、JVM、类加载器八个部分。 语法细节数据类型1234567891011java数据类型图： ┏数值型━┳━整数型：byte short int long ┏基本数据类型━━┫ ┗━浮点型：float do ┃ ┣字符型：char 数据类型╋ ┗布尔型：boolean ┃ ┏类（class） ┗引用数据类型━━╋接口（interface） ┗数组（array）String也是属于引用数据类型System.out.println(&quot;123&quot; instanceof Object);//trueSystem.out.println(new int[2] instanceof Object); //true Integer&amp;intInteger.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比 12345678910public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.***[i + (-IntegerCache.low)]; return new Integer(i); &#125;Integer.valueOf("100")==Integer.valueOf("100") //trueInteger.valueOf("200")==Integer.valueOf("200") //falseInteger.valueOf("200")==200 //true Byte Byte类型值大小为-128~127之间。 a=127;add(++a);这里++a会越界，a的值变为-128 ，再++a 变为 -127。 switchswitch支持 byte、short、char、int或者其对应的封装类、Enum类型、String。 final 修饰变量，变量的引用地址不可变，但是地址中的内容可以变。 修饰方法，方法不可被重写，但是还是可以重载 修饰类，类不可继承。 StringString c = &quot;my&quot; + &quot;String&quot;;会在编译时对”my” + “String”进行拼接成myString字符串，再去常量池查找，找到之后指向该字符串地址，所以 c == &quot;myString&quot;; //true String获取长度用的是length（）方法，而数组类型我们直接用属性length获取长度 StringBuilder , StringBuffer ,String 都是 final 的 数组使用Arrays.equals() 是比较两个数组中的内容。 ByteByte是byte的包装类型，初始化为null而不是0 floatfloat：小数如果不加 f 后缀，默认是double类型。double转成float向下转换，意味着精度丢失，所以要进行强制类型转换。Object o = ‘f’;：’f’ 字符会自动装箱成包装类，就可以向上转型成Object了。Double d = 100;：整数默认是int类型，int类型不能转型为Double，最多通过自动装箱变为Integer但是Integer与Double没有继承关系，也没法进行转型。 Thread.yield()Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。 GBK-&gt;UTF-8GBK编码字节流到UTF-8编码字节流的转换：byte[] src,dst; dst=new String(src，&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;) 异常异常的继承结构：基类为Throwable，Error和Exception继承Throwable，Exception又分为运行时异常和编译时异常,RuntimeException和 IOException等继承Exception，具体的RuntimeException继承RuntimeException。编译时异常是未雨绸缪性质的异常，是防范，需要显示处理。运行时异常是程序员问题造成，并不强制进行显示处理。运行时异常的特点是Java编译器不会检查它。 语法特点访问权限作用域java的访问权限有public、protected、private和default的，default不能修饰变量 数值操作两个数值进行二元操作时，会有如下的转换操作：如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，如果其中一个操作数是float类型，另一个将会转换为float类型。否则，如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。double&gt;float&gt;long&gt;int Java表达式转型规则由低到高转换：1、所有的byte,short,char型的值将被提升为int型；2、如果有一个操作数是long型，计算结果是long型；3、如果有一个操作数是float型，计算结果是float型；4、如果有一个操作数是double型，计算结果是double型；5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。b3 = b1+b2; 若b1、b2为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型 包装类包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱包装类的equals()方法不处理数据转型 字节&amp;字符字符流 = 字节流 + 编码集stream结尾都是字节流，reader和writer结尾都是字符流 两者的区别就是读写的时候一个是按字节读写，一个是按字符。 实际使用通常差不多。在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。只是读写文件，和文件内容无关的，一般选择字节流。 中间缓存变量机制int i = 0; i = i++; =》 i=0; Java使用了中间缓存变量机制：i=i++;等同于：temp=i； (等号右边的i)i=i+1; (等号右边的i)i=temp; (等号左边的i) 构造方法普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。构造方法是在对象创建时就被调用，用于初始化。 在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。 子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。而父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数。 多态 重写和重载是多态的两种表现形式 子类继承了父类的所有成员，包括private权限的成员变量，但是继承的子类具有私有变量的拥有权但是没有使用权。private的成员变量，根据权限修饰符的访问控制范围，只有在类内部才能被访问，就算是他的子类，也不能访问。 重写方法的重写（override）两同两小一大原则：方法名相同，参数类型相同子类返回类型小于等于父类方法返回类型，子类抛出异常小于等于父类方法抛出异常，子类访问权限大于等于父类方法访问权限。 静态 静态语句块中x为局部变量，不影响静态变量x的值 并不是静态块最先初始化,而是静态域（类加载初始化时执行）而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的! 修饰非静态方法 锁的是this 对象，修饰静态方法 锁的是class对象 静态方法属于类的成员，实例方法属于对象的成员。 super&amp;thissuper和this都只能位于构造器的第一行，而且不能同时使用，这是因为会造成初始化两次，this用于调用重载的构造器，super用于调用父类被子类重写的方法 面向对象五个基本原则：单开利益接单一职责原则（Single-Resposibility Principle）： 一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 开放封闭原则（Open-Closed principle）： 软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 Liskov替换原则（Liskov-Substituion Principle）： 子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 依赖倒置原则（Dependecy-Inversion Principle）： 依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 接口隔离原则（Interface-Segregation Principle）： 使用多个小的专门的接口，而不要使用一个大的总接口 接口&amp;抽象类抽象类可以含有私有成员变量，接口不含有私有成员变量。接口中的成员变量都是public static final的，一般用作常量。接口中的方法都是抽象方法，接口中的方法默认修饰符有public abstract。 抽象类特点: 抽象类中可以存在构造方法、普通属性，方法，静态属性和方法、抽象方法 如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。 抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。 抽象类构造函数的作用是什么？可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。 接口 在接口中只有常量，没有变量声明，因为定义的变量，在编译的时候都会默认加上public static final 接口中没有构造方法，也不能实例化接口的对象。 接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。 方法还有被static或default修饰，一旦被修饰，这个方法必须有方法体。 版本变化JDK1.8之后，接口中的方法也可以有方法体。Java8的接口方法可以有：only public, abstract, default, static and strictfp are permitted 内部类1.成员内部类 成员内部类是最普通的内部类，它的定义为位于另一个类的内部 在外部类外部 创建非静态内部类 语法： 外部类.内部类 内部类对象 = new 外部类().new 内部类(); 举例：Outer.Inner in = new Outer().new Inner();2.局部(方法)内部类 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。只能用abstract和final修饰。3.匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。匿名内部类时，必须继承一个类或实现一个接口。4.静态内部类 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。在外部类外部 创建静态内部类语法： 外部类.内部类 内部类对象 = new 外部类.内部类();举例： Outer.Inner in = new Outer.Inner(); 关于非静态内部类不能有静态成员（可以有常量），是关于谁先加载的问题如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字,如:Outer.this.name 集合框架线程安全vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。statck：堆栈类，先进后出hashtable：就比hashmap多了个线程安全enumeration：枚举，相当于迭代器 SetSet存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。如果自定义对象做为Map的键，那么必须重写hashCode和equals。 ListList扩容实现步骤 总的来说就是分两步： 1、扩容把原来的数组复制到另一个内存空间更大的数组中 2、添加元素把新元素添加到扩容以后的数组中int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);oldCapacity &gt;&gt; 1 右移运算符 原来长度的一半 再加上原长度也就是每次扩容是原来的1.5倍 HashMap 使用的链地址法来解决冲突的。 使用的是平衡树来解决提高效率的。 HashMap中hash数组的默认大小是16，而且一定是2的指数。 负载因子是0.75，即默认情况下是16x0.75=12时，就会触发扩容一倍操作。 比如说，我们有1000个元素new HashMap(1000)因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。(原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 ) ArrayListArrayList内部是动态数组实现，在增加空间时会复制全部数据到新的容量大一些的数组中。而LinkedList内部为双向链表，可以按需分配空间，扩展容量简单，因此LinkedList用时少。 ConcurrentHashMapJDK1.8 的 ConcurrentHashMap 采用CAS+Synchronized保证线程安全。 JDK1.7 及以前采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock，因此采用Lock锁来保证线程安全。 CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换（自旋锁或乐观锁）更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。 但是Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。 JVM内存模型 方法区方法区在JVM中也是一个非常重要的区域，它与堆一样，是被 线程共享 的区域。 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。 类加载器 比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。 什么是类加载器？把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。类的加载包括：加载，验证，准备，解析，初始化。所有ClassLoader装载的类都来自CLASSPATH环境指定的路径。 有哪些类加载器，分别加载哪些类类加载器按照层次，从顶层到底层，分为以下三种：(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类(2)扩展类加载器 : 它用来加载 Java 的扩展库。(3)应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。 双亲委派模型我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为：类加载器的双亲委派模型，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的。 双亲委托模型的工作原理当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。 实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。 使用双亲委派模型好处？（原因） 避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。 安全，String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器。 自定义类加载器自定义类加载器实现 继承ClassLoader后重写了findClass方法加载指定路径上的class 两个类是否“相等”？《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。 类只需加载一次，类加载过程线程安全]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年总结]]></title>
    <url>%2F2020%2F01%2F13%2F2019-summary%2F</url>
    <content type="text"><![CDATA[2019年总结今天是1月13号了，现在才想起把总结写写，虽是太晚，但也是最快了。2019总得来说就是累，但却又不够累，或者说是没有达到想象中的累，或许是因没有达到自己设立的目标的情绪作祟吧。 今年毕业了没错，2019今年是我毕业的一年，正式从学校步入社会，这个身份的转变正式终结了我16年来的学生身份，十六年想想可真是漫长，却又快的不得了，时间转瞬即逝，我想大多数学生对进入社会还是需要一定的时候去过渡的。好高骛远，眼高手低我想是大多数学生的通病，但是理想还是要有的，目标设立了就要去做，务实一点才好。大学的生活现在想想无疑使怀念的，从中总有段时间从某种意义上来说是我们的人生中的第一段无忧无虑的生活，或许在在这段生活之后就会进入青春的迷茫期，大多数人也是有的，或许也会有些抑郁的情况，但是我想应该自己走出来，自己经过思考之后选择的才是最适合自己的，当然或许会犯错，但是想想我们的年龄，是有试错时间的，最害怕的就是不敢，不敢破圈。再看看我们的工作前景，Java固然工作好找也不容易失业，但是做的总感觉心里不舒坦，或许这就是想象很丰满，现实很骨感吧。看着那些所谓的白菜价，是羡慕的，也想去试试，工作也想去挑战，想去大公司，但是总归是自己的能力有限，之前是没有见识过，但是现在想想矛盾是相互的，或许去不了也不是一件坏事。所以下半年就决定去考研了。 考研虽然现在分数还没有出来，但是总得来说是失败的，失败在哪里呢？1：时间分配不均2：实际和认识存在偏差 我的时间分配大致是 英语&gt;&gt;&gt;数学&gt;专业课&gt;政治 因为我的英语是从小到考研的超级短板，或许在考研之前我就没有入门，我总是这么想，现在想来高三的时候也是因为一直为了提英语的分，导致了其它科目的时候分配不太够，虽然最后结果出来还能看。但是考研就不同了，数学专业课是拉分的，今年的数学很难，英语也比较难，但是我做英语做完感觉很稳，数学却是严重翻车。这种情况下及时英语考上70也没有什么希望了，所以以后一定要谋定而后动，大体计划是很重要的，要心中有数。当然考研这段经历也是让自己清楚认识到了自己有哪些不足，也算是沉淀了一番，心中沉得住气才是最重要的。知识什么时候都要学，目标也要有，但是更重要的是做好现在的事情。年后大概二月初就准备上成都找工作了，现在好好准备一番，想在天府新区那边找一家公司，看2020如何继续发展吧。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 上的标红]]></title>
    <url>%2F2019%2F11%2F17%2Fidea-error%2F</url>
    <content type="text"><![CDATA[intellJ 上的标红 spring boot Configuration Annotation Proessor not found in classpath解决方案：导入依赖12345&lt;dependency&gt; &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt; spring-boot-configuration-processor &lt;/artifactId&gt; &lt;optional&gt; true &lt;/optional&gt;&lt;/dependency&gt; 若是还标红 重启下intellJ就行了 Could not autowire. No beans of &#39;xxxxMapper&#39; type found解决方案：安装 Mybatis Plugin 插件注意Mybatis Plugin是收费的 另外有一个Free Mybatis Plugin但是没有效果 cannot resolve property under construction in mybatis-mapper.xml解决方案：1：输全路径。2 在modules下spring中添加Application xml 错误页面 错误页面路径配置 server.error.path(默认error) 异常处理器来进行日志输出（Spring Boot提供了） 123456789//Controller 辅助类ControllerAdvicepublic class ErrorHandler&#123; @ExceptionHandler(value=&#123;Exception.class,RuntimeException.class&#125;) public String error500(HttpServletRequest request,Exception e)&#123; logger.error(request.getRequestURL()+" 500") return "error/500"; &#125;&#125;]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>项目笔记</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误合集]]></title>
    <url>%2F2019%2F10%2F17%2Ferror-list-1%2F</url>
    <content type="text"><![CDATA[错误合集Mybatis错误：Parameter ‘XXX’ not found. Available parameters are[1, 0, param1, param2] base64 to imagebase64 to image MySQL字段自增自减的SQL语句 idea的xml文件Tag name expected 123456789101112131415161718192021222324252627282930[ERROR] 11:54:46.645 [Tomcat-startStop-1] o.apache.catalina.core.ContainerBase - A child container failed during startjava.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Tomcat].StandardHost[localhost].TomcatEmbeddedContext[]] at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:192) at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:941) at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:872) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1421) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1411) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)Caused by: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Tomcat].StandardHost[localhost].TomcatEmbeddedContext[]] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167) ... 6 common frames omittedCaused by: org.apache.catalina.LifecycleException: Failed to start component [Pipeline[StandardEngine[Tomcat].StandardHost[localhost].TomcatEmbeddedContext[]]] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5166) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) ... 6 common frames omittedCaused by: org.apache.catalina.LifecycleException: Failed to start component [org.apache.catalina.authenticator.NonLoginAuthenticator[]] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167) at org.apache.catalina.core.StandardPipeline.startInternal(StandardPipeline.java:182) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) ... 8 common frames omittedCaused by: java.lang.NoSuchMethodError: javax.servlet.ServletContext.getVirtualServerName()Ljava/lang/String; at org.apache.catalina.authenticator.AuthenticatorBase.startInternal(AuthenticatorBase.java:1183) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) ... 10 common frames omitted 关键点在于 Caused by: java.lang.NoSuchMethodError: javax.servlet.ServletContext.getVirtualServerName()Ljava/lang/String;在javax.servlet包中 ServletContext类中的 getVirtualServerName() 没有这样的方法错误，()Lxxx表示方法声明返回值为String类型的方法，但是当你点进方法中去看的时候确实又存在，所以很有可能就是javax.servlet包冲突了，有另外一个javax.servlet包存在但是他没有 getVirtualServerName() 这样的方法，所以需要去看看你导入的其它Jar包是哪个和它冲突了，如果是用的maven 只需使用exclusions即可。比如我的就是axis2-kernel包中的和Tomact中的servlet包冲突了 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.axis2&lt;/groupId&gt; &lt;artifactId&gt;axis2-kernel&lt;/artifactId&gt; &lt;version&gt;1.7.8&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; mavne工程运行报错：软件包javax.crypto 不存在解决办法 springboot Jar包 秒部署到Linux服务器运行 jenkins部署jar项目、springboot项目部署 maven 如何引入本地jar包 SpringBoot多模块项目打包方法（jar和war） Spirng boot maven多模块打包踩坑 国家sql]]></content>
      <categories>
        <category>错误合集</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>maven</tag>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C学习笔记-指针]]></title>
    <url>%2F2019%2F10%2F10%2Fc-note-linux%2F</url>
    <content type="text"><![CDATA[Linux C指针gdb基本使用查看内存：x（输出内存的值）/3（显示值的数量）d（以十进制显示） 0x7fffffffde14（从哪个地址开始显示 * 指针符 表示地址指向的空间&amp; 取地址符 1bit = 8二进制位 int类型 32位 占4个字节指针保存的就是内存的地址内存地址：64位OS下 一个内存地址 = 8bit32位OS下 一个内存地址 = 4bit数据段：全局变量（所有函数共用）、常量、静态变量（某个函数特有的） 代码编译后存在代码段外还会存在栈中没调用一个函数就会调用栈内存编译时会优化 先把同类型的变量申明同时一起执行 OS会把内存看成一个整体来计算内存的大小32bit 地址总线（寻址空间是）是32位 最大使用4G内存32位指的是：给内存的编号只能编到32个二进制位地址总线可以存在多种状态，32根地址总线就有2^32个状态 栈是由上往下生成代码段 数据段 （是不允许随便修改的 一开始就加入了内存中）是由下往上生成 int quadraate(int a);是一个函数int （*pquadrate)(int a)=&amp;quadrate;将指针pquadtate指向函数quadrate！int s=(*pquadrate)(a)可以调用quadtate函数，这种操作常用于回调函数若“p”是一个地址，则“*p”是到这个地址去取里面的值，“（*p）”把表示为一个整体，“（*p）（数据）”若p为代码段，则调用这个函数，传参数”数据”进去。若地址指向的是栈和堆，操作系统会把栈或者堆的具体数据取出来，若地址指向的不是一个栈或者堆，而是代码段的话，操作系统会认为是指向某一个函数 指针运算 指针和数组本质上都是地址 数组能做的指针都能做但是array永远指的都是同一个地址 不能在地址上做偏移 是一种指针常量 12345678int *p=&amp;a;p+=3;//表示地址指针的偏移运算，把内存地址往下移动三格 12个字节*p=101;//这两句等同于p[3]=101 但是p[]这种p的指针没有变p++;//表示地址指针往下移动一格 因为p是int类型 所有每格为4个字节p = &amp;a;//*p表示所指向的内存空间的值;//p是所指向内存空间的内存首地址;//&amp;p 是指p指针变量在内存中的地址; 字符数组 123char str[] = &quot;abc&quot;;//栈内存中char *str2 = &quot;abc&quot;;//str2指向的是代码段，abc是常量字符串，不可以被修改char str3 = [10];//栈内存中 字符串以\0结束指针变量char *str2 = “hello”，用scanf 向str2中输入字符串出错，其实也可以这么理解，指针str2只是指向一个地址，从这个地址开始写入”hello”,没有指定内存长度，没有空间去容纳字符串。内存溢出！这个与char str[] = “hello”不同，str已经有了6个字节的内存空间， C语言在内存中数据的存储位置char a[] = “linux”占6个字节，a存储的是首地址，“linux”可以在栈，也可以在堆中char *p = “linux”占10个字节，p指针变量占4字节，里面保存的是后面字符串的地址，“linux”占6个字节，存储在代码段。 超出存储范围后 程序会按照地址顺序继续存储后面的字符]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C学习笔记-基本结构]]></title>
    <url>%2F2019%2F10%2F05%2Fc-note%2F</url>
    <content type="text"><![CDATA[C笔记语言中，数据类型可分为：基本数据类型，构造数据类型，指针类型，空类型四大类。 整型、实型与字符型。 注：int、short int、long int是根据编译环境的不同，所取范围不同。而其中short int和long int至少是表中所写范围，但是int在表中是以16位编译环境写的取值范围。另外 c语言int的取值范围在于他占用的字节数 ，不同的编译器，规定是不一样。ANSI标准定义int是占2个字节，TC是按ANSI标准的，它的int是占2个字节的。但是在VC里，一个int是占4个字节的。 ###格式化输出语句 格式化输出语句，也可以说是占位输出，是将各种类型的数据按照格式化后的类型及指定的位置从计算机上显示。 其格式为：printf(“输出格式符”，输出项); C语言中的常用格式化符： 注意：格式符的个数要与变量、常量或者表达式的个数一一对应 常量C语言的常量可以分为直接常量和符号常量。直接常量也称为字面量，是可以直接拿来使用，无需说明的量。在C语言中，可以用一个标识符来表示一个常量，称之为符号常量。符号常量在使用之前必须先定义，其一般形式为： #define 标识符 常量值 符号常量的标示符一般习惯使用大写字母，变量的标示符一般习惯使用小写字母，加以区分。注意：#define 放置于main() 前，结尾无分号，量是不可改变的 ###自动类型转换 自动转换发生在不同数据类型运算时，在编译的时候自动完成。 char类型数据转换为int类型数据遵循ASCII码中的对应值，ASCII码请查看WIKI。 注：字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换 ###强制类型转换 强制类型转换是通过定义类型转换运算来实现的。其一般形式为：(数据类型) (表达式) 在使用强制转换时应注意以下问题： 1、数据类型和表达式都必须加括号，如把(int)(x/2+y)写成(int)x/2+y则成了把x转换成int型之后再除2再与y相加了。 2、转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。 3、强制转换后的运算结果不遵循四舍五入原则（是向下取整 -2.5 —&gt; -3）。 ###运算符 取余运算中注意：该运算只适合用两个整数进行取余运算，如：10%3 = 1；而10.0%3则是错误的；运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%(-3) = 1。 ###优先级 for循环顺序 它的执行过程如下： 第一步：执行表达式1，对循环变量做初始化； 第二步：判断表达式2，若其值为真（非0），则执行for循环体中执行代码块，然后向下执行；若其值为假（0），则结束循环； 第三步：执行表达式3； 第四步：执行for循环中执行代码块后执行第二步； 第五步：循环结束，程序继续向下执行。 ###自创函数 自定义函数的一般形式： 注意： 1、[ ]包含的内容可以省略，数据类型说明省略，默认是int类型函数；参数省略表示该函数是无参函数，参数不省略表示该函数是有参函数； 2、函数名称遵循标识符命名规范； 3、自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数，声明格式为：[数据类型说明] 函数名称（[参数]）; C语言没有重载。但是C语言作为一个具有超强功能的底层语言，是有办法进行模拟函数重载的。那就是函数指针。最简单的例子就是qsort函数。这个函数可以传递一个函数指针变量，通过不同的函数指针，可以对不同的数据类型就行相同的qsort操作，从某种层面来说相当于函数重载。 C语言中局部变量可以与全局变量同名在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内 ###变量存储类别C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。 静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。 动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。 C语言中存储类别又分为四类：自动（auto）、静态（static）、寄存器的（register）和外部的（extern）。 1、用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式。 2、用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。 3、为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明。注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。 4、用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。 ###内部函数与外部函数在C语言中不能被其他源文件调用的函数称谓内部函数 ，内部函数由static关键字来定义，因此又被称谓静态函数，形式为： static [数据类型] 函数名（[参数]） 这里的static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。 在C语言中能被其他源文件调用的函数称谓外部函数 ，外部函数由extern关键字来定义，形式为： extern [数据类型] 函数名([参数]) C语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。 数组它在程序中是一块连续的，大小固定并且里面的数据类型一致的内存空间，它还有个好听的名字叫数组。 C语言中的数组初始化是有三种形式的，分别是：注意括号只能放在数组名称后，传参不用加括号，形参需要加括号1、 数据类型 数组名称[长度n] = {元素1,元素2…元素n}; 2、 数据类型 数组名称[] = {元素1,元素2…元素n}; 3、 数据类型 数组名称[长度n]; 数组名称[0] = 元素1; 数组名称[1] = 元素2; 数组名称[n-1] = 元素n; 如果采用第一种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为0；在声明数组后没有进行初始化的时候，静态（static）和外部（extern）类型的数组元素初始化元素为0，自动（auto）类型的数组的元素初始化值不确定。 定义一个数组，开辟一段内存空间，这段内存空间并不会像被围墙围住一样被封死，合理地利用这个数组，需要程序员自己控制。只定义了这段空间，只有这段空间内的数据对于你当前的程序是合理的，越界的话就不知道你访问到哪里去了，它可能属于机器上任何一个运行着的进程，因为机器上的进程使用的都是这一条内存。如果你修改了你越界访问到的数据，可能会造成未知的错误。int a[3] = {1,2,3};这样的定义，a表示的是开辟的这一段空间的首地址，[]里的数字表示相对这个地址的偏移量，访问数组是这样进行的你可以通过sizeof()获得某个类型的大小，但是程序运行时不会去检查下标是否越界。这样的检查是需要耗费资源的，理想的情况下，这样做对于程序运行也没有意义。C/C++没有这样做这样的检查，C#、java 都是有这样的检查的 1234int a[10] = &#123;0&#125;;int cnt = sizeof(a) / sizeof(a[0]);输出结果是：cnt = 10 这样不管数组是增加还是减少元素，sizeof(a)/sizeof(a[0]) 都能自动求出数组的长度。需要注意的是，它求出的是数组的总长度，而不是数组中存放的有意义的数据的个数。int a[10] = {1, 2, 3, 4, 5};我们只初始化了五个元素，但是 sizeof(a)/sizeof(a[0]) 求出的是 10，而不是 5。换句话说，我们无法通过 sizeof(a)/sizeof(a[0]) 求出数组中有多少个有意义的数据。 字符串与数组在C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。一般有以下两种格式： 1、char 字符串名称[长度] = “字符串值”; 2、char 字符串名称[长度] = {‘字符1’,’字符2’,…,’字符n’,’\0’}; 注意： 1、[]中的长度是可以省略不写的； 2、采用第2种方式的时候最后一个元素必须是’\0’，’\0’表示字符串的结束标志； 3、采用第2种方式的时候在数组中不能写中文。 在输出字符串的时候要使用：printf(“%s”,字符数组名字);或者puts(字符数组名字); 字符串函数#include &lt;string.h&gt; 使用字符串函数注意以下事项: 1、strlen()获取字符串的长度，在字符串长度中是不包括’\0’而且汉字和字母的长度是不一样的。 2、strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0表示s1和s2的ASCII码相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ASCII码小。 3、strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝。 4、strcat()在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串， 多维数组数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n];我们可以把上面的数组看作一个3×3的矩阵，如下图: 多维数组的初始化与一维数组的初始化类似也是分两种: 1、数组名称[常量表达式1][常量表达式2]...[常量表达式n] 12、```数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; 数组名称[下标1][下标2]...[下标n] = 值; 多维数组初始化要注意以下事项: 1、采用第一种始化时数组声明必须指定列的维数。因为系统会根据数组中元素的总个数来分配空间，当知道元素总个数以及列的维数后，会直接计算出行的维数, 2、采用第二种初始化时数组声明必须同时指定行和列的维数。 二维数组定义的时候，可以不指定行的数量，但是必须指定列的数量。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误合集2]]></title>
    <url>%2F2019%2F10%2F01%2Ferror-list-2%2F</url>
    <content type="text"><![CDATA[错误合集2网页效果 需要时间 加载缓慢的时候 注意排除 css 中或者 js中的网址 一帮使用@import 引入网址 enctype=”multipart/form-data”表单传值问题 linux 后台启动java jar(守护线程) maven打可执行的jar包，将配置文件打到外面。pom.xml里面的配置 导入数据库常用source 命令进入mysql数据库控制台，如mysql -u root -pmysql&gt;use 数据库然后使用source命令，后面参数为脚本文件(如这里用到的.sql)mysql&gt;source d:/dbname.sql spring-boot 禁用swagger的方法 java.lang.NoClassDefFoundError: org/apache/tomcat/util/http/mapper/Mapper 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;$&#123;embedded.tomcat.version&#125;&lt;/version&gt;&lt;/dependency&gt; maven打包pom文件节点在windows和linux下的格式差异 ${path.separator}这个分隔符，在Windows系统下是“;”分号，在Linux下是“:”冒号。为了使打包时自动选择，可以使用${path.separator}。 1The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib] 解决Linux下Tomcat由于Tomcat Native问题启动报错linux 安装apr 然后libtcnative-1.so 把这个移到/usr/lib64下 enctype=”multipart/form-data”表单传值问题]]></content>
      <categories>
        <category>错误合集</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>mysql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STS与SpringBoot]]></title>
    <url>%2F2019%2F08%2F17%2Fsts%2F</url>
    <content type="text"><![CDATA[STSSTS(Spring Tool Suite™)Spring工具套件是一个基于Eclipse的开发环境，用于开发Spring应用程序。它提供了一个现成的环境以实现、调试、运行和部署Spring应用程序，包括Pivotal tc Server、Pivotal Cloud Foundry、Git、Maven、AspectJ的集成，并且位于最新的Eclipse版本之上。 Spring工具套件包括Pivotal tc Server的开发者版本，它是Apache Tomcat的下拉替换，为Spring进行了优化。通过它的Spring Insight控制台，tc Server Developer Edition提供了应用程序性能度量的图形化实时视图，允许开发人员从他们的桌面识别和诊断问题。 Spring工具套件支持以本地、虚拟和基于云的服务器为目标的应用程序。它可免费用于开发和内部业务操作，没有时间限制，完全开放源代码，并根据Eclipse公共许可证条款进行许可。 对于Spring Boot有着很好的支持 *实际用着感受而言 外貌和eclipse一模一样 要稍微好看点 ， 但是用着没有eclipse流畅 错误提示没有intellJ好 可以说是基本没有 电脑稍微差点及其容易未响应 ，eclipse很少 intellJ几乎没有 * Spring Boot介绍 目标：简单，快速开发Spring框架项目 特性1：自动配置（无需xml配置，通过jar依赖自动识别） 特性2：通过启步（Starter）依赖集成第三方库，开箱即用 特性3：内嵌Servlet容器，无需war包部署 特性4：内置健康检测、度量指标功能 特性5：提供all-in-one打包插件 Spring Boot两种创建方式 方式一：使用Spring Initiallizr创建 方式二：使用Spring Tool Suite等IDE创建 ####引入Spring Boot 方式一：pom继承spring-boot-starter-parent（当需要修改其中的依赖管理版本号时，可以直接覆盖或者修改Properties版本号变量） 方式二：pom引入spring-boot-dependencies（这种模式修改Properties版本号是不起作用的，只能覆盖） 引入内嵌容器 引入tomcat：直接引入spring-boot-starter-web，默认tomcat 引入jetty：还需添加spring-boot-starter-jetty，并移除starter-tomcatUse Jetty instead of Tomcat ####内嵌容器优势 减少外部容器依赖，可移植性高 易测试易部署 Spring Boot提供了可插拔的内嵌容器方案 数据访问层搭建-整合MyBatis 方式一：通过xml配置 1：dataSource配置 2：创建SqlSessionFactoryBean，MapperSacnnerConfigurer bean 3：创建mybatis配置文件，mapper接口类及sql映射文件 方式二：通过Starter 1：引入mybatis Starter 2：application.properties添加spring mybatis和datasource配置 3：创建mybatis配置文件，mapper接口类及sql映射文件 数据传输层需要配置在和启动类在同一层级添加@Mapper 才会被自动扫描到不然就只有用在启动类上面使用@MapperScan配置 数据库连接池 — DruidSpringBoot 默认的使用Tomcat连接池：tomcat-jdbc Druid Druid是一个JDBC组件库，包括数据库连接池、SQL Parser等组件。DruidDataSource是最好的数据库连接池。 Druid 1.1.101234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;&lt;/dependency&gt; 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364server.port=8080#Druid配置spring.datasource.druid.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.druid.username=rootspring.datasource.druid.password=123#连接池配置(通常来说，只需要修改initialSize、minIdle、maxActive#如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false。#分库分表较多的数据库，建议配置为false。removeabandoned不建议在生产环境中打开如果用SQL Server，建议追加配置)#初始化连接大小spring.datasource.druid.initial-size=8#最大连接数spring.datasource.druid.max-active=30#最小连接数spring.datasource.druid.min-idle=5#一般情况下 Druid以上配置足以#启用ConfigFilterspring.datasource.druid.filter.config.enabled=true#下面两个配置可有可无 默认也是这个配置#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒spring.datasource.druid.time-between-eviction-runs-millis=60000#配置一个连接在池中最小生存的时间，单位是毫秒spring.datasource.druid.min-evictable-idle-time-millis=300000#获取连接的最大等待时间spring.datasource.druid.max-wait=10000#解决mysql提出超过8小时空闲的连接的问题 主动定期验证内存里面的连接是否有效 用来检测连接是否有效的sql，要求是一个查询语句，常用select &apos;x&apos;spring.datasource.druid.validation-query=SELECT &apos;x&apos;spring.datasource.druid.test-on-borrow=falsespring.datasource.druid.test-on-return=falsespring.datasource.druid.test-while-idle=true#打开PSCache，并且指定每个连接上PSCache的大小spring.datasource.druid.pool-prepared-statements=truespring.datasource.druid.max-pool-prepared-statement-per-connection-size=20#Druid内置提供一个StatFilter，用于统计监控信息。#DruidFilter慢SQL追查 1ms上的 是否打印 是否合并spring.datasource.druid.filter.stat.enabled=truespring.datasource.druid.filter.stat.slow-sql-millis=1spring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.merge-sql=true#监控配置# WebStatFilter配置，说明请参考Druid Wiki，配置_配置WebStatFilter#是否启用StatFilter默认值truespring.datasource.druid.web-stat-filter.enabled=truespring.datasource.druid.web-stat-filter.url-pattern=/*spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*spring.datasource.druid.web-stat-filter.session-stat-enable=falsespring.datasource.druid.web-stat-filter.session-stat-max-count=1000spring.datasource.druid.web-stat-filter.principal-session-name=adminspring.datasource.druid.web-stat-filter.principal-cookie-name=adminspring.datasource.druid.web-stat-filter.profile-enable=true#Druid内置提供了一个StatViewServlet用于展示Druid的统计信息。#StatViewServlet的用途包括：1.提供监控信息展示的html页面2.提供监控信息的JSON API#是否启用StatViewServlet默认值true 映射地址/druidspring.datasource.druid.stat-view-servlet.enabled=truespring.datasource.druid.stat-view-servlet.url-pattern=/druid/* 若是报错请先检查druid jar包是否正常 ，可能存在版本冲突，导致maven没有导入完整的druid jar包，但是却没有报错 整合freemarker步骤 方式一 通过xml配置 1：pom引入freemarker库 2：创建freemarkerConfigurer、viewResolver bean 3：编写模板引擎文件 方式二 通过Starter 1：引入freemarker starter 2：application.properties添加freemarker配置 3：编写模板引擎文件 Freemarker结构化布局 抽取header、footer、nav、js、分页 页面中引入header、footer 编写页面中自定义的部分. 起步依赖（Starter）一： spring-boot-starter——spring-boot————spring-core————spring-context——spring-boot-autoconfigure（包含大量自动配置）——spring-boot-starter-logging 二： mybatis-spring-boot-starter——mybatis——spring-boot-starter-jdbc——mybatis-spring——mybatis-spring-boot-autoconfigure 自动配置 @SpringApplicationBoot -&gt; @EnableAutoConfiguration -&gt; SpringFactoriesLoader(classpath:/META-INF/spring.factories)@EnableXxxx Java Config中有很多注解configuration 代表它是一个Java Config会有一些条件注解ConditionalOnMissingBean 如果不存在这个Bean则创建 当用户创建时这个Bean就不生效@ConditionalOnProperty 如果开启某个配置则这个Bean则创建@ConditionalOnClass 在某些类存在的情况下 才去加载 自定义自动配置列子：访问网站都是以Http访问的，就需要HttpClient 单例就可以 是一个SpringBean的存在 12345678910111213141516171819202122232425262728293031323334@Configuration@ConditionalOnClass(&#123;HttpClient.class&#125;)//将HttpClientProperties 作为一个Bean引入进来@EnableConfigurationProperties(HttpClientProperties.class)public class HttpClientAutoConfiguration &#123; private final HttpClientProperties properties; public HttpClientAutoConfiguration(HttpClientProperties properties)&#123; this.properties = properties; &#125; /** * httpClient bean 的定义 * @return */ @Bean @ConditionalOnMissingBean(HttpClient.class) public HttpClient httpClient()&#123; RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(properties.getConnectTimeOut()) .setSocketTimeout(properties.getSocketTimeOut()) .build(); HttpClient client = HttpClientBuilder.create() .setDefaultRequestConfig(requestConfig) .setUserAgent(properties.getAgent()) .setMaxConnPerRoute(properties.getMaxConnPerRoute()) .setMaxConnTotal(properties.getMaxConnTotaol()) .setConnectionReuseStrategy(new NoConnectionReuseStrategy()) .build();//setConnectionReuseStrategy 不进行重试 可以在业务中进行 不在http中 return client; &#125;&#125; 就是需要启动给application.properties这个文件,提供给用户 进行配置的 12345678910111213//声明为一个SpringBoot的配置文件@ConfigurationProperties(prefix="spring.httpclient")public class HttpClientProperties &#123; private Integer connectTimeOut = 1000; //连接超时 1s private Integer socketTimeOut = 10000; //读超时 10s private String agent = "agent"; private Integer maxConnPerRoute = 10; //每个IP最大连接数 private Integer maxConnTotaol = 50; //总连接数....getter....setter&#125; 因为上面两个类是在root Package下的子Package，所以加了@configuration 都会被自动扫描到也会自动加载进来，当不是子Package下的时候，就会报错找不到HttpClient这个Bean，这个时候可以使用META-INF 进行配置 12345resources-- META-INF-- spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\xxx.xxx.xxx.HttpClientAutoConfiguration 另一种方法是使用注解 123456789101112131415import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.context.annotation.Import;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import(HttpClientAutoConfiguration.class)public @interface EnableHttpClient &#123; &#125;//然后在启动类上加上注解 @EnableHttpClient 就行了 maven 多module的实现 好处：让我们代码层次逻辑更加清晰，增强代码的内聚性，可以使多人负责不同的module，增加协同开发的效率它并不意味着分布式，最终还是要打成一个jar包，多module通过 maven依赖最终会集成到一起 拆分例子 house-biz：负责数据访问层以及业务的实现 house-common：负责定义数据模型以及公共代码 house-web：负责定义启动类、controller、模板引擎 工作组使用和建立 intellj 直接创建maven项目 -&gt; 在这个项目下 右键 new moudle]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>STS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中调用JS]]></title>
    <url>%2F2019%2F04%2F17%2Fjava-make-js%2F</url>
    <content type="text"><![CDATA[Java中调用JSJDK自带的类可以实现调用JS的功能，可以实现执行字符串中的运算公式的功能。 123456789101112131415public class runString &#123; static ScriptEngine jse = new ScriptEngineManager().getEngineByName("JavaScript"); /** * @param args */ public static void main(String[] args) &#123; String strs = "1+1*2+(10-(2*(5-3)*(2-1))-4)+10/(5-0)"; try &#123; System.out.println(jse.eval(strs)); &#125; catch (Exception t) &#123; &#125; &#125;&#125; 注意：如果公式中存在变量作为运算的元素的话，可以借鉴使用replaceAll()方法将相应的变量替换成实际的数值。如果是多个变量可以利用循环遍历的方式来解决。 例子：jse.eval(“1+b”.replaceAll(“b”, b.toString()))；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 中的登录验证]]></title>
    <url>%2F2019%2F01%2F17%2Fspringboot-login-verify%2F</url>
    <content type="text"><![CDATA[SpringBoot 中的登录验证authoritiesByUsernameQuery(sql)传入的sql 需要返回 用户名和 用户级别 源码中的默认sql 1private String authoritiesByUsernameQuery = "select username,authority from authorities where username = ?"; usersByUsernameQuery(sql)传入的sql 需要返回 用户名,密码,是否启动 enabled = 1 是默认启用源码中的默认sql 1"select username,password,enabled from users where username = ?"; 另一种验证方案 1234567891011121314151617181920@Autowired AdminUserService adminUserService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth .userDetailsService(buildUserDetailsService()) .passwordEncoder(new BCryptPasswordEncoder()); &#125; @Bean UserDetailsService buildUserDetailsService() &#123; return username -&gt; &#123; AdminUser account = adminUserService.selectByUsername(username); User user = new User(account.getName(), account.getPasswd(), true, true, true, true, AuthorityUtils.createAuthorityList("USER")); return user; &#125;; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>项目笔记</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年总结]]></title>
    <url>%2F2018%2F12%2F31%2F2018-summary%2F</url>
    <content type="text"><![CDATA[2018年总结2018年，是收获的一年，收获的最多的除了知识就是肉了。 上半年从1月寒假到5月的初夏，不断的深入学习成为了一名自认为合格的 ‘Java-er’，善用网上的资源你基本可以得到所有你想要得到的，自认为真正学会了什么是专注。 下半年5月底的初夏，想必是不热，正是找工作的好天气，在27号的周一这天，找到了一份我的初次起航工作，工作了半年多的时间中，代码写的有，项目也做的有，书也看，博客也搭起来了，当时想必是有些意气风发的感觉吧，现在想来当时的想法还是有些好高骛远了。 end2018年掉了两次手机，以后一定要注意！最后 “前进的路上不进则退 ” 还要继续加油！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC流程]]></title>
    <url>%2F2018%2F12%2F19%2Fspringmvc-process%2F</url>
    <content type="text"><![CDATA[SpringMVC流程 首先从左到右是客户端发起用户请求，以Http形式进入到Servlet容器中 Servlet容器解析Http数据成为一个EndPonit对象 EndPonit对象里面包含请求url、httpheader以及检验完或者读完的包内数据流 进入用户自定义的Filter，在Filter中用户可以对request进行处理，经过多个Filter处理完后 进入DisPatcherServlet（SpringMvc的入口），先进入到解析器（MultipartResolver）中，解析成对应的自己的流，以及把一些字符串K-V读出来封装到对象中，以供后续的Controller接收，除此就是通过请求URL寻找Handler（就是我们定义的Controller）过程了 由于我们在Controller方法中注解了RequestMapping映射，在启动过程中通过RequestMapping就会把URL与Controller对应方法注册到HandlerMapping中，如果无法在HandlerMapping找到请求对应的Controller，就会报404错误。否则会进入HandlerInterceptor（拦截器） HandlerInterceptor（拦截器）可以打印日志，做身份鉴权等一些操作，处理完后Spring会对数据进行绑定还会对数据进行验证，由RequestMapping注解方法里面的方法参数进行绑定，返回反射调用我们的Controller方法，这个时间就进入到具体的Controller方法体里面了 在Controller方法体中我们调用相应的Service进行处理，从Controller出来后，就开始创建ModelAndView这个对象了（Model：数据、View：模板），这个时候的View只是一个ViewName 如果我们定义了异常处理器，在拦截器处理数据绑定、数据验证处理这些所有的环节，只要出现了异常都会被异常处理器拦截掉，并在异常处理中返回相应的500页面 拦截器在做PostHandler之后，通过ViewResolver进行View（模板）的资源定位，找不到就转404页面 找到View之后，就是一个渲染页面的过程，实际是将数据进行模板变量替换的过程，数据来自Request，ModelMap、Session中，之后就通过DispatcherServlet方法、再Filter的后缀处理，最终通过Servlet容器返回客户端]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中Model,ModelMap以及ModelAndView]]></title>
    <url>%2F2018%2F11%2F19%2Fspring-model%2F</url>
    <content type="text"><![CDATA[Spring中Model,ModelMap以及ModelAndView之间的区别model 都是为了从控制层直接返回前端所需的数据 ① ModelModel是一个接口，它的实现类为ExtendedModelMap，继承ModelMap类1public class ExtendedModelMap extends ModelMap implements Model ② ModelMapModelMap继承LinkedHashMap，spring框架自动创建实例并作为controller的入参 1public class ModelMap extends LinkedHashMap&lt;String,Object&gt; ③ ModelAndView顾名思义，ModelAndView指模型和视图的集合，既包含模型 又包含视图；ModelAndView的实例是开发者自己手动创建的，这也是和ModelMap主要不同点之一列子 123456789@RequestMapping(value = "/mergeModel")public ModelAndView mergeModel(Model model) &#123; model.addAttribute("a", "a");//1添加模型数据 ModelAndView mv = new ModelAndView("success"); mv.addObject("a", "update");//2在视图渲染之前更新③处同名模型数据 model.addAttribute("a", "new");//3修改1处同名模型数据 //视图页面的a将显示为"update" 而不是"new" return mv;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在桌面应用开发项目中的异步操作 - SwingWorker]]></title>
    <url>%2F2018%2F09%2F05%2Fswingworker%2F</url>
    <content type="text"><![CDATA[前言在桌面应用程序开发的过程中难免会去使用数据，那么这些数据来自哪里呢，数据库、服务器、网络、本地文件等到。这些操作我们统一称作费时操作。若是使用同步开发的话，桌面应用程序UI则会等待这些费时操作完成之后才会更新UI，而使用异步的话，则不会影响，我更新我的UI，你获取做完这些费时操作再通知我，把数据传给我就好了。所以在JDK1.6时候推出了——SwingWorker 12345678910javax.swingClass SwingWorker&lt;T,V&gt;java.lang.Object javax.swing.SwingWorker&lt;T,V&gt;类型参数：T- this SwingWorker's doInBackground和getmethods 返回的结果类型V- 用于通过此方法SwingWorker's publish和process方法执行中间结果的类型所有已实现的接口：Runnable，Future &lt;T&gt;，RunnableFuture &lt;T&gt; 使用Swing编写多线程应用程序时，需要记住两个约束: 不应在Event DispatchThread上运行耗时的任务。否则应用程序将无响应。 应仅在Event Dispatch Thread上访问Swing组件。这些约束意味着具有时间密集型计算的GUI应用程序需要至少两个线程：1）执行冗长任务的线程和2）所有GUI相关活动的事件调度线程（EDT）。这涉及线程间通信，这可能很难实现。SwingWorker适用于需要在后台线程中运行长时间运行任务并在完成或处理时为UI提供更新的情况。子类SwingWorker必须实现该doInBackground()方法来执行后台计算。 工作流程 当前线程：execute()在此线程上调用该方法。它计划SwingWorker在工作 线程上执行 并立即返回。可以等待SwingWorker完成使用get方法。*get() 方法最好在done()方法中调用，这样才能保证操作是完成的 * 工作线程：doInBackground() 在此线程上调用该方法。这是所有背景活动应该发生的地方。要通知 PropertyChangeListeners绑定属性更改，请使用 firePropertyChange和 getPropertyChangeSupport()方法。默认情况下，有两个绑定属性可用：state和progress。 事件调度线程：此线程上发生所有与Swing相关的活动。SwingWorker调用 process和done()方法并PropertyChangeListeners在此线程上通知任何方法。 SwingWorker仅设计为执行一次。执行 SwingWorker多次不会导致doInBackground两次调用该 方法。 官方实例 123456789101112131415161718192021222324252627282930313233343536373839class PrimeNumbersTask extends SwingWorker&lt;List&lt;Integer&gt;, Integer&gt; &#123; PrimeNumbersTask(JTextArea textArea, int numbersToFind) &#123; //initialize &#125; @Override public List&lt;Integer&gt; doInBackground() &#123; while (! enough &amp;&amp; ! isCancelled()) &#123; number = nextPrimeNumber(); publish(number); setProgress(100 * numbers.size() / numbersToFind); &#125; &#125; return numbers; &#125; @Override protected void process(List&lt;Integer&gt; chunks) &#123; for (int number : chunks) &#123; textArea.append(number + "\n"); &#125; &#125;&#125;JTextArea textArea = new JTextArea();final JProgressBar progressBar = new JProgressBar(0, 100);PrimeNumbersTask task = new PrimeNumbersTask(textArea, N);task.addPropertyChangeListener( new PropertyChangeListener() &#123; public void propertyChange(PropertyChangeEvent evt) &#123; if ("progress".equals(evt.getPropertyName())) &#123; progressBar.setValue((Integer)evt.getNewValue()); &#125; &#125; &#125;);task.execute();System.out.println(task.get()); //打印所有的素数 日常使用 12345678910111213141516171819202122232425class ProgressWorker extends SwingWorker&lt;List&lt;Data&gt;, Void&gt; &#123; private JPanel panel; private Boolean isValidateBtn; public ProgressWorker(JPanel panel, Boolean isValidateBtn) &#123; this.panel = panel; this.isValidateBtn = isValidateBtn; &#125; @Override protected void done() &#123; panel.setVisible(false); try &#123; new ShowPage(get(), isValidateBtn); //跳转到下一个界面 并把数据传过去 &#125; catch (Exception e) &#123; &#125; &#125; @Override protected List&lt;Data&gt; doInBackground() &#123; return Dispatcher.getDataList(); //重数据库拿到数据 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>项目笔记</tag>
        <tag>SwingWorker</tag>
        <tag>桌面应用程序</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在桌面应用开发项目中走过的凹]]></title>
    <url>%2F2018%2F09%2F05%2Fxmbj-ao%2F</url>
    <content type="text"><![CDATA[前言此文章结合了在项目开发过程中遇到并解决的一些问题和难点，以及一些比较好用的model，引以启发。 junit 单元测试 不支持多线程测试，当主线程结束时整个进程就会结束。若是想要执行子线程那么 可以使用 Thread.sleep() 对主线程进行睡眠，使用 子线程.join()可以让该子线程先执行完再执行主线程，但是这种方法只适用于 线程使用start()方法启动的。 不用Servlet容器去启动Spring，在main方法里面启动Spring1234ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:spring/spring-dao.xml", "classpath:spring/spring-service.xml" );//获取Beanac.getBean(serviceName); 对JButton大小的设置因为JButen是属于小器件类型的，所以一般的setSize不能对其惊醒大小的设置，所以一般我们用button.setPreferredSize(new Dimension(30,30));,对于其它组件如 JMenuBar 也同样适用。 public void setUndecorated(boolean undecorated)禁用或启用此框架的外部边框。默认是启用，使用这个方法时要注意放置的位置 需要在组件显示之前设置。一般设置在init方法中的前几行。 在使用全局字体的过程中发现，有些字体使用了样式，而有些却没有使用，我想这是因为我把全局字体放到了子线程中加载的原因，于是我把它放到主线程Main方法中，果然就行了。 若是使用了全局字体，一样的可以在组件中使用设置字体方法.setFont()去覆盖全局效果。 JPanel 背景图设置 1234567panel = new JPanel()&#123; @Override protected void paintComponent(Graphics graphics) &#123; ImageIcon icon = new ImageIcon("images\\background.jpg"); graphics.drawImage(icon.getImage(), 0, 0, frame.getWidth(), frame.getHeight(), frame); &#125; &#125;; JButton 带文字背景图设置 12345678JButton showDocButton = new JButton("预览");showDocButton.setIcon(new ImageIcon("images\\show.png"));showDocButton.setHorizontalTextPosition(SwingConstants.CENTER);//文字居中showDocButton.setContentAreaFilled(false); //背景透明showDocButton.setBorderPainted(false); //无边框public void setContentAreaFilled(boolean b)设置contentAreaFilled属性。 如果true这个按钮将画出内容区域。 如果您希望有一个透明按钮，例如仅图标按钮，那么您应该将其设置为false 。 不要使用setOpaque(false) 。 使用MigLayout布局，这种布局非常适合充当表格布局，而且里面的每列每行的大小都可以调，可以配合scrollPane使用pdf官方文档12345&lt;dependency&gt; &lt;groupId&gt;com.miglayout&lt;/groupId&gt; &lt;artifactId&gt;miglayout-swing&lt;/artifactId&gt; &lt;version&gt;5.2&lt;/version&gt;&lt;/dependency&gt; 123456panel.setLayout(new MigLayout("", "[30][40][50][60]", "[50]"));//布局代表4列3行 (Layout Constraints,Column constraints,Row constraints)JButton Button_1 = new JButton("New button");panel.add(Button_1 , "cell 1 0,alignx center");//把这个按钮放在第1列0行 位于这个区域的中心 日志模板 注意log4j.properties 需要放到classpath一级下（resources）才能生效不能放在其它文件夹中 123456789101112131415161718192021222324### 设置###log4j.rootLogger = info,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=//logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = logs\\log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = INFOlog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=//logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File = logs\\error.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = ERRORlog4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>项目笔记</tag>
        <tag>桌面应用程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目笔记 —— Word模板开发]]></title>
    <url>%2F2018%2F09%2F05%2Fxmbj-word%2F</url>
    <content type="text"><![CDATA[前言在项目中遇到，需要使用数据库里面的数据填入word模板中，最后找到了FreeMarker，可以说是非常好用了。 Apache FreeMarker™是一个模板引擎：一个Java库，用于根据模板和更改数据生成文本输出（HTML网页，电子邮件，配置文件，源代码等）。模板是用FreeMarker模板语言（FTL）编写的，这是一种简单的专用语言（不像PHP这样的完整编程语言）。通常，使用通用编程语言（如Java）来准备数据（发布数据库查询，进行业务计算）。然后，Apache FreeMarker使用模板显示准备好的数据。在模板中，您将关注如何呈现数据，而在模板之外，您将关注于要呈现的数据。 FreeMarker 官方文档 创建配置实例首先，您必须创建一个 freemarker.template.Configuration实例并调整其设置。一个Configuration实例是存储FreeMarker的应用水平设置的中心位置。此外，它还处理预解析模板（即 对象）的创建和 缓存Template。通常，您只在应用程序（可能是servlet）生命周期开始时执行此操作一次： 12345678910111213141516171819202122//创建您的Configuration实例，并指定是否属于FreeMarker//版本（此处为2.3.27）是否要应用非100％的修补程序// 向下兼容。有关详细信息，请参阅配置JavaDoc。配置cfg = new配置（Configuration.VERSION_2_3_27）;//指定模板文件的来源。我在这里设置了一个//它的普通目录，但也可以使用非文件系统源：cfg.setDirectoryForTemplateLoading（new File（“ / where / you / store / templates ”））;//设置存储的首选charset模板文件.UTF-8是//在大多数应用程序中都是一个很好cfg.setDefaultEncoding（ “UTF-8”）;//设置错误的显示方式。//在网页*开发期间* TemplateExceptionHandler.HTML_DEBUG_HANDLER更好。cfg.setTemplateExceptionHandler（TemplateExceptionHandler.RETHROW_HANDLER）;//不要在FreeMarker中记录它会抛出的异常：cfg.setLogTemplateExceptions（假）;//将模板处理期间抛出的未经检查的异常包装到TemplateException-s中。cfg.setWrapUncheckedExceptions（真）; 从现在开始，您应该使用这个单一 配置实例（即它的单例）。但请注意，如果系统有多个使用FreeMarker的独立组件，那么他们当然会使用自己的私有 Configuration实例。 不要不必要地重新创建Configuration 实例; 它很昂贵，其中包括你丢失了模板缓存。Configuration实例意味着应用程序级单例。 我的使用 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.28&lt;/version&gt;&lt;/dependency&gt; 首先建立一个Word文档 在需要填充的地方写上几个字母或者数字方便等会定位别用空格或者特殊符号 另存为XML文件 查找&lt;w:t&gt; 之前填充地方填的字母 &lt;/w:t&gt; 然后把字母改成需要映射的方法或者属性${getName()} 或者 ${Name} 改完后把后缀名改为 .ftl 或者 .ftlh 然后就可以开始写代码了1234567891011121314151617181920212223242526272829303132333435363738//根据上面官网所说 我们需要它是一个单例import java.io.File;import java.io.IOException;import freemarker.template.Configuration;import freemarker.template.TemplateExceptionHandler;public class Freemark &#123; private Freemark() &#123; &#125; private static class CfgSingleton &#123; private static final Configuration CFG = new Configuration(Configuration.VERSION_2_3_28); static &#123; try &#123; CFG.setDirectoryForTemplateLoading(new File("templates")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; CFG.setDefaultEncoding("UTF-8"); //设置错误的显示方式。 //在网页开发期间 TemplateExceptionHandler.HTML_DEBUG_HANDLER更好。 CFG.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); //不要在FreeMarker中记录它会抛出的异常： CFG.setLogTemplateExceptions(false); //将模板处理期间抛出的未经检查的异常包装到TemplateException-s中。 CFG.setWrapUncheckedExceptions(true); &#125; &#125; public static Configuration getCfg() &#123; return CfgSingleton.CFG; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.doc.Freemark;import com.entity.Data;import freemarker.template.Configuration;import freemarker.template.Template;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.swing.JOptionPane;import java.io.*;import java.text.SimpleDateFormat;import java.util.Date;/** * @author ： @gf * Create on 2018/8/20 14:05 */public final class DocMapperUtil &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DocMapperUtil.class); // Data是实体类记录文档信息 Object是需要映射进去的数据是另一个实体类对应ftlh中的方法或者变量 public static String mapper(Object obj, Data data) &#123; Configuration cfg = Freemark.getCfg(); Writer out; String path = ""; try &#123; Template template = cfg.getTemplate(data.getName()+".ftlh");// Template template = cfg.getTemplate("Demo.ftlh"); File file = new File("fillInWord\\" + data.getName() + new SimpleDateFormat("yyyy-MM-dd_hh-mm-ss").format(new Date()) + ".doc"); out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "UTF-8")); path = file.getAbsolutePath(); data.setToDocPath(path); //把obj中数据映射到文档中 template.process(obj, out); out.close(); &#125; catch (Exception e) &#123; LOGGER.info("映射失败",e); JOptionPane.showConfirmDialog(null, "信息映射失败，该文件没有您的信息", "错误", JOptionPane.YES_NO_OPTION); return ""; &#125; return path; &#125;&#125; 为了简化第2和第3步的操作*我的规则是文档中每个需要的地方写上get{Num} 对应 Class 中的getFunc() 然后替换掉，需要注意的是顺序一定要是一样的，当然也可以在Xml中写上对应的方法然后做判断再替换 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;/** * @author ： @gf * Create on 2018/9/4 11:38 */public class DocToXmlUtil &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DocToXmlUtil.class); public static void toDo(Class&lt;?&gt; c,String Path) &#123; if (!Path.endsWith("xml")) &#123; try &#123; throw new Exception("文件路径不是一个xml文件"); &#125; catch (Exception e) &#123; LOGGER.error("!Path.endsWith(\"xml\"):",e); &#125; &#125; List&lt;String&gt; funName = new ArrayList&lt;&gt;(); for(Method method : c.getDeclaredMethods()) &#123; if (method.getName().startsWith("get")) &#123; funName.add(method.getName()); &#125; &#125; FileInputStream fis = null; InputStreamReader isr = null; BufferedReader br = null; StringBuilder stringBuilder = null; FileOutputStream fos = null; OutputStreamWriter osw = null; try &#123; fis = new FileInputStream(Path); isr = new InputStreamReader(fis, "UTF-8"); br = new BufferedReader(isr); stringBuilder = new StringBuilder(); String line; while((line = br.readLine()) != null)&#123; stringBuilder.append(line); &#125; &#125; catch (Exception e) &#123; LOGGER.error("文件读取异常",e); &#125;finally &#123; try &#123; if (br != null)&#123; br.close(); &#125; if (isr != null)&#123; isr.close(); &#125; if (fis != null)&#123; fis.close(); &#125; &#125; catch (IOException e) &#123; LOGGER.error("文件读取关闭异常",e); &#125; &#125; String xmlStr = null; if (stringBuilder != null) &#123; xmlStr = stringBuilder.toString(); for (int i = 1; i &lt;= funName.size(); i++) &#123; xmlStr = xmlStr.replace("get"+i, "$&#123;"+funName.get(i-1)+"()"+"&#125;"); &#125; &#125; try &#123; int s = 0; if (Path.contains("\\")) &#123; s = Path.lastIndexOf("\\")+1; &#125;else if (Path.contains("/")) &#123; s = Path.lastIndexOf("/")+1; &#125; String resource = Path.substring(s, Path.lastIndexOf(".")); fos = new FileOutputStream(new File("templates\\"+resource+".ftlh")); osw = new OutputStreamWriter(fos, "UTF-8"); if (xmlStr!= null) &#123; osw.write(xmlStr); &#125; osw.flush(); &#125; catch (Exception e) &#123; LOGGER.error("文件写入异常",e); &#125;finally &#123; try &#123; if (osw != null)&#123; osw.close(); &#125; if (fos != null)&#123; fos.close(); &#125; &#125; catch (IOException e) &#123; LOGGER.error("文件写入关闭异常",e); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>项目笔记</tag>
        <tag>Word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目笔记 —— Word To PDF To Image]]></title>
    <url>%2F2018%2F09%2F05%2Fxmbj-wpi%2F</url>
    <content type="text"><![CDATA[前言在项目中需要使用桌面应用程序显示Word文档，并实现一个放大缩小的效果。但是我发现Word并不能直接转换成Image格式，所以就取了一个折中的方法。先把Word转换为PDF，再把PDF转换成Image。 jacob-1.18.dll版本下载 1234567891011121314 &lt;!-- pdfToImage --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;1.8.15&lt;/version&gt;&lt;/dependency&gt;&lt;!-- docToPdf --&gt;&lt;!-- 将jacob-1.18.dll 文件复制到对应位数的..java\jdk\bin目录下--&gt;&lt;dependency&gt; &lt;groupId&gt;com.hynnet&lt;/groupId&gt; &lt;artifactId&gt;jacob&lt;/artifactId&gt; &lt;version&gt;1.18&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.jacob.activeX.ActiveXComponent;import com.jacob.com.ComThread;import com.jacob.com.Dispatch;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * @author ： @gf * Create on 2018/8/24 11:16 */public class DocToPdfUtil &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DocToPdfUtil.class); public static String formatConvert(String resourcePath) &#123; String resource = resourcePath.substring(0, resourcePath.lastIndexOf(".")); if (resourcePath.endsWith("doc")) &#123; toPdf(resourcePath, resource + ".pdf"); &#125; return resource + ".pdf"; &#125; private static void toPdf(String docPath, String toPafName) &#123; ActiveXComponent activeXComponent = null; try &#123; ComThread.InitSTA(); activeXComponent = new ActiveXComponent("Word.Application"); //不显示转换界面 activeXComponent.setProperty("Visible", false); LOGGER.info("toPdf() ...ing"); Dispatch dispatch = activeXComponent.getProperty("Documents").toDispatch(); dispatch = Dispatch.call(dispatch, "Open", docPath, false, true).toDispatch(); //17 代表 doc 转 pdf的级别 Dispatch.call(dispatch, "ExportAsFixedFormat", toPafName, 17); Dispatch.call(dispatch, "Close", false); LOGGER.info("toPdf() ...over"); &#125; catch (Exception e) &#123; LOGGER.error("doc to pdf failure", e); &#125; finally &#123; if (activeXComponent != null) &#123; activeXComponent.invoke("Quit", 0); &#125; ComThread.Release(); &#125; &#125;// public static void main(String[] args) &#123;// formatConvert("E:\\workspace32\\Test\\fillInWord\\Demo.doc");// &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041import org.apache.pdfbox.pdmodel.PDDocument;import org.apache.pdfbox.pdmodel.PDPage;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.swing.*;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;/** * @author ： @gf * Create on 2018/8/24 14:10 */public class PdfToImageUtil &#123; private static final Logger LOGGER = LoggerFactory.getLogger(PdfToImageUtil.class); public static Image toImage(String pdfFileName) &#123; ImageIcon imageIcon = null; try &#123; PDDocument pdDocument = PDDocument.load(new File(pdfFileName)); int pageCount = pdDocument.getNumberOfPages(); PDPage pdPage = (PDPage) pdDocument.getDocumentCatalog().getAllPages().get(0); BufferedImage bufferedImage = pdPage.convertToImage(); if (bufferedImage != null) &#123; imageIcon = new ImageIcon(Toolkit.getDefaultToolkit().createImage(bufferedImage.getSource())); &#125; pdDocument.close(); LOGGER.info("PDF To Image Success"); &#125; catch (IOException e) &#123; LOGGER.error("To Image Failure:", e); &#125; if (imageIcon != null) &#123; return imageIcon.getImage(); &#125; else &#123; return new ImageIcon().getImage(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>项目笔记</tag>
        <tag>桌面应用程序</tag>
        <tag>Word</tag>
        <tag>PDF</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目笔记 - windowbuilder&桌面应用程序开发]]></title>
    <url>%2F2018%2F08%2F27%2Fjava-windowbuilder%2F</url>
    <content type="text"><![CDATA[前言 WindowBuilder - 是一个功能强大且易于使用的双向Java GUI设计器WindowBuilder由SWT Designer和Swing Designer组成，可以非常轻松地创建Java GUI应用程序，而无需花费大量时间编写代码。使用WYSIWYG可视化设计器和布局工具为复杂窗口创建简单的表单; 将为您生成Java代码。使用拖放轻松添加控件，向控件添加事件处理程序，使用属性编辑器更改控件的各种属性，使应用程序国际化等等。WindowBuilder是作为Eclipse和各种基于Eclipse的IDE（RAD，RSA，MyEclipse，JBuilder等）的插件而构建的。该插件构建了一个抽象语法树（AST）来导航源代码并使用GEF来显示和管理可视化表示。生成的代码不需要任何其他自定义库来编译和运行：可以在不安装WindowBuilder Pro的情况下使用所有生成的代码。WindowBuilder Pro几乎可以读写任何格式，并可以反向工程大多数手工编写的Java GUI代码。它还支持自由格式代码编辑（在任何地方进行更改……不仅仅是在特殊区域）和大多数用户重新分解（您可以移动，重命名和细分方法而不会出现问题）—— Google 翻译 插件安装 Eclipse -&gt; Help -&gt; Install New Software 版本选择 选择合适的版本 (建议选择Integration Version 的)点击Link 把跳转的网址添加到Work with 点击 next 若是一直加载， 把Contact all update sites during install to find reauired software 这项的勾去掉 面板 常用模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374initialize()//固定面板大小frame.setResizable(false);//获得屏幕大小dToolkit tk = Toolkit.getDefaultToolkit();Dimension d = tk.getScreenSize();//充满屏幕frame.setSize(d);//无边框frame.setUndecorated(true);main()//使用自带UIfor (UIManager.LookAndFeelInfo info:UIManager.getInstalledLookAndFeels()) &#123; if ("Nimbus".equals(info.getName())) &#123; UIManager.setLookAndFeel(info.getClassName()); break; &#125;&#125;/** * 自带三个UI * Metal 默认UI * Nimbus 个人感觉这个是里面最好的 * CDE/Motif * 系统自带UI * Windows =》 Windows 、Windows Classic * Mac =》 Mac OS X * 其它 =》 GTK+ *///显示界面frame.setVisible(true);//设置全局字体 static&#123; Font font = new Font("仿宋", Font.BOLD, 15); FontUIResource fontRes = new FontUIResource(font); for (Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys(); keys.hasMoreElements(); ) &#123; Object key = keys.nextElement(); Object value = UIManager.get(key); if (value instanceof FontUIResource) &#123; UIManager.put(key, fontRes); &#125; &#125; &#125;//全局ESC 触发退出static&#123; Toolkit.getDefaultToolkit().addAWTEventListener( new AWTEventListener() &#123; public void eventDispatched(AWTEvent awtEvent) &#123; if (awtEvent.getID() == KeyEvent.KEY_PRESSED)&#123; KeyEvent event = (KeyEvent)awtEvent; if (event.getKeyCode() == KeyEvent.VK_ESCAPE)&#123; Object[] options = &#123;"确定","取消"&#125;; int response= JOptionPane.showOptionDialog(null, "确认退出？", "",JOptionPane.YES_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if(response==0) &#123; frame.dispose(); System.exit(0); &#125; &#125; &#125; &#125; &#125;,AWTEvent.KEY_EVENT_MASK);&#125; 获取焦点1234567requestFocusInWindowpublic boolean requestFocusInWindow()如果这个组件的顶级祖先已经是焦点窗口，则请求该组件获得输入焦点。这个组件必须是可显示的、可聚焦的、可见的，并且它的所有祖先(顶级窗口除外)必须是可见的，才能被授予请求。void setFocusable(boolean focusable) 设置此组件的是否可以**聚焦的状态**。 而不是获得焦点。 ###JDialog 弹窗聚焦 12345678910111213public static enum Dialog.ModalityTypeextends Enum&lt;Dialog.ModalityType&gt;模态对话框阻止某些顶级窗口的所有输入。 特定窗口是否被阻止取决于对话框的类型; 这被称为“阻塞范围”。 ModalityType枚举指定模态类型及其关联范围。 APPLICATION_MODAL APPLICATION_MODAL对话框将阻止来自同一Java应用程序的所有顶级窗口，但不包括其子层次结构中的顶级窗口。 DOCUMENT_MODAL 一个 DOCUMENT_MODAL对话框阻止输入到同一文档的所有顶级窗口，不同于它自己的子层次结构。 MODELESS MODELESS对话框不会阻止任何顶级窗口。 TOOLKIT_MODAL TOOLKIT_MODAL对话框阻止所有从同一工具包运行的顶级窗口，除了自己的子层次结构。 注意：如果在调用该Dialog时使用了 setVisible(true) 在其初始化的时候又使用了一次 setVisible(true) ，正常情况下不会看见有什么异常，但是若是加了APPLICATION_MODAL，则会让你关闭两次才行]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>windowbuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目笔记 - JNA]]></title>
    <url>%2F2018%2F08%2F17%2Fjava-jna%2F</url>
    <content type="text"><![CDATA[JNA Java Native Access（JNA）JNA为Java程序提供了对本机共享库的轻松访问，而无需编写除Java代码之外的任何内容 - 不需要JNI或本机代码。此功能可与Windows的Platform / Invoke和Python的ctypes相媲美。 JNA允许您使用自然Java方法调用直接调用本机函数。Java调用看起来就像本机代码中的调用一样。大多数呼叫不需要特殊处理或配置; 不需要样板或生成的代码。 JNA使用小型JNI库存根来动态调用本机代码。开发人员使用Java接口来描述目标本机库中的函数和结构。这使得利用本机平台功能变得非常容易，而不会产生为多个平台配置和构建JNI代码的高额开销。 虽然对性能给予了极大的关注，但正确性和易用性优先考虑。 此外，JNA还包括一个平台库，其中已经映射了许多本机函数，以及一组简化本机访问的实用程序接口。—— 以上Google翻译 JNA jar包自己使用的 github挂载 4.5.2 官网的 JNA Examples JNA 英文文档 JNA 英文概述 stackoverflow-JNA 官网入门教程 官网小实例1234567891011121314151617181920212223242526package com.sun.jna.examples;import com.sun.jna.Library;import com.sun.jna.Native;import com.sun.jna.Platform;public class HelloWorld &#123; // 这是标准的，稳定的映射方式，它支持广泛的 // 自定义和Java到本机类型的映射 public interface CLibrary extends Library &#123; CLibrary INSTANCE = (CLibrary) Native.load((Platform.isWindows() ? "msvcrt" : "c"), CLibrary.class); void printf(String format, Object... args); &#125; public static void main(String[] args) &#123; CLibrary.INSTANCE.printf("Hello, World\n"); for (int i=0;i &lt; args.length;i++) &#123; CLibrary.INSTANCE.printf("Argument %d: %s\n", i, args[i]); &#125; &#125;&#125; 官网使用详解 使您的目标库可用于Java程序。让你的类路径中的本地库，该路径下{OS}-{ARCH}/{LIBRARY}，这里{OS}-{ARCH}是JNA对本地库规范前缀（如win32-x86，linux-amd64或darwin）。如果资源在jar文件中，则在加载时将自动提取。（PS:不多的话直接放在项目根目录下就好了。) 在此接口中，使用Native.load（Class）方法定义本机库的实例，提供先前定义的本机库接口。 123456Kernel32 INSTANCE = (Kernel32) Native.load("kernel32", Kernel32.class); // 可选：在异步块中封装对本地库的每个调用，每次限制本地调用一个Kernel32 SYNC_INSTANCE = (Kernel32) Native.synchronizedLibrary(INSTANCE); 该INSTANCE变量用于方便地重用库的单个实例。或者，您可以将库加载到局部变量中，以便在超出范围时可用于垃圾回收。可以提供选项映射作为加载以定制库行为的第三个参数; 这SYNC_INSTANCE也是可选的; 如果您需要确保您的本机库一次只能调用一次，请使用它。 12345678910111213141516171819@FieldOrder(&#123; "wYear", "wMonth", "wDayOfWeek", "wDay", "wHour", "wMinute", "wSecond", "wMilliseconds" &#125;)public static class SYSTEMTIME extends Structure &#123; public short wYear; public short wMonth; public short wDayOfWeek; public short wDay; public short wHour; public short wMinute; public short wSecond; public short wMilliseconds;&#125;void GetSystemTime(SYSTEMTIME result);...Kernel32 lib = Kernel32.INSTANCE;SYSTEMTIME time = new SYSTEMTIME();lib.GetSystemTime(time);System.out.println("Today's integer value is " + time.wDay); 我的实例操作DemoDll .dll是一个C++写的dll文件，放在项目根目录下就好和src同级 1234567891011121314151617181920212223242526import com.sun.jna.Library;import com.sun.jna.Native;import com.sun.jna.Structure;import com.sun.jna.ptr.IntByReference;public final class Demo &#123; protected interface CLibrary extends Library&#123; CLibrary INSTANCE = (CLibrary) Native.loadLibrary("DemoDll",CLibrary.class); // 对应C++中的 HRESULT GetStauts(WORD *wStatus) // 传入的是基本类型的引用 int GetStauts(IntByReferce wStatus); // 对应C++中的 BOOL OpenSTP(COM com) 传入的是对象引用 Boolean Open(COM.ByReference struct); public static class COM extends Structure&#123; public short fwCom; public int fwBaud; public byte fwByteSize; ... public static class ByReference extends COM implements Structure.ByReference&#123;&#125; &#125; &#125; 对应上面的COM 123456typedef struct _com &#123; short fwCom; WORD fwBaud; BYTE fwByteSize; &#125; COM, *LPCOM; 123456...main...final COM.ByReference com = new COM.ByReference();Boolean bool = CLibrary.INSTANCE.Open(com);final IntByReference wStatus = new IntByReference();int status = CLibrary.INSTANCE.GetStauts(wStatus);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JNA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想笔记（四）]]></title>
    <url>%2F2018%2F08%2F10%2Fjava-bcsx-note-4%2F</url>
    <content type="text"><![CDATA[类型信息运行时类型信息使得你可以在程序运行时发现和使用类型信息 Java是如何让我们在运行时识别对象和类信息。 “传统的”RTTI，它假定我们在编译时就已经知道了所有的类型； 另一种是“反射”机制，允许我们在运行时发现和使用类的信息。 运行时类型识别(RTTI, Run-Time Type Identification)在Java运行时，RTTI维护类的相关信息，识别一个对象类型。多态(polymorphism)是基于RTTI实现的。RTTI的功能主要是由Class类实现的。 Class对象 JVM实现的一部分——“类加载器”的子系统去生成类对象。类加载器子系统包含一条类加载器链，但是只有一个原生类加载器。原生类加载器加载的是可信类（包括Java API类），通常是从本地盘加载的。在类加载器链中通常不需要添加额外的类加载器，但是如果有特殊需求（例如在网络中加载类），那么有一种方式可以添加额外的类。所有的类在对其第一次使用时，动态的加载到JVM中。Java程序在它开始运行之前并非完全被加，其各个部分是在必需时才加载的。类加载器首先会检查这个类的Class对象是否已经加载，若没有加载，则会去寻找类名.class的文件，其被加载时会被验证，以确保安全和正确。 Class.forName(&quot;ClassName&quot;);这个方法是Class类（所有Class对象都属于这个类）的一个static成员。Class对象就和其它对象一样，我们可以获取并操作它的引用（这也就是类加载器的工作）。forName()是取得Class对象的引用的一种方法。它是包含目标类的文本名的的String作输入参数，返回的是一个Class对象引用 类字面常量Java还提供了类字面常量的方式来生成Class对象的引用。ClassName.Class这样做不仅更简单而且更安全，因为它在编译时就会受到检查(因此不需要置于try语句块中)。并且它根除了对forName()方法的调用，所以也更加高效。因为forName()是运行时才加载，必须置于try语句块中。另外基本数据类型的包装类有一个包装类.TYPE字段对应该包装类.class当使用.class去创建对象的引用时，不会自动初始化该类Class对象。为了使用类做准备的三个步骤 加载，由类加载器执行，该步骤将查找字节码，并从这些字节码中创建一个Class对象 链接，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其它类所有引用。 初始化，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块 泛化的Class引用在JavaSE5中，Class&lt;?&gt;优于Class，即便他们是等价的 123Class&lt;? extends Number&gt; c = int.class;c = double.class;c = Number.class; 这种写法只是为了提供编译器类型检查，直接写Class则会运行时才报错 类转型语法 cast()1234567891011public class T1 &#123; public static void main(String[] args) &#123; A1 a1 = new A2(); Class&lt;A2&gt; a2Type = A2.class; A2 a2 = a2Type.cast(a1); a2 = (A2)a1; // or just do this &#125;&#125;class A1&#123;&#125;class A2 extends A1&#123;&#125; cast()对于无法使用普通转型的情况显得非常有用 需要记得的是在转型前检查类型是否是我们需要的那种 这里就用到了instanceof 列if(x instanceof Dog) ((Dog)x).wangwang();也可使用Class.isInstance()方法提供了一种动态地测试对象的途径。 反射：运行时的信息如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它，并利用这些信息。 如果你需要获取一个指向某个不在你的程序空间中的对象的引用（列如从网络中或者磁盘中获取一串字节，并且被告知这些字节代表一个类） class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field、Method、Constructor类(每个类都实现了Member接口)。这些类型的对象是由JVM在运行是创建的，用以表示未知类里对应的成员。 所以RTTI和反射真正的区别只在于，对RTTI来说，编译器在编译时打开和检查.class文件。而反射机制来说，.class文件在编译时是不可获取的，是在运行时打开和检查的.class文件。 123456789//用反射机制遍历类中的方法try &#123; Class&lt;?&gt; c = Class.forName("com.xxx.xxx.ClassName"); for(Method m : c.getMethods())&#123; System.out.println(m.toString()); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 反射可以使你访问和修改类的任何私有方法 类 接口，只有final域在遭遇修改时是安全的。运行系统会在不抛出异常的情况下接受任何修改尝试，但是实际上是不会发生任何修改的 动态代理 代理是基本的设计模式之一。它是你为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。这些操作通常涉及与“实际对象的通信，因此代理通常充当着中间人的角色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class T1 &#123; public static void consumer(Iface iface)&#123; iface.doSomething("bobobo"); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject(); consumer(real);//未使用代理直接传入真实的对象 ClassLoader loader = Iface.class.getClassLoader(); Class&lt;?&gt;[] interfaces = new Class[]&#123;Iface.class&#125;; InvocationHandler h = new DynamicProxyHandler(real); // Proxy.newProxyInstance 创建动态的代理 Object obj = Proxy.newProxyInstance(loader,interfaces, h); Iface proxy = (Iface)obj; consumer(proxy);//使用代理传入处理过后的实际对象 &#125;&#125;class DynamicProxyHandler implements InvocationHandler&#123; private Object proxied; public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //invoke内，对接口的调用将会被重定向为对代理的调用 -- 这句不太理解 ((Iface)proxied).doSomething("lalala"); return method.invoke(proxied, args); &#125;&#125;interface Iface&#123; void doSomething(String arg);&#125;class RealObject implements Iface&#123; @Override public void doSomething(String arg) &#123; System.out.println(arg); &#125; &#125; 动态代理可以将所有调用 重定向 到调用处理器 ，因此通常需要传递一个实际对象，使得调用处理器在执行其中任务时，可以将请求转发。 空对象1234567891011121314151617interface Null&#123;&#125;class Person&#123; Person(String first)&#123;&#125; private static class NullPerson extends Person implements Null&#123; private NullPerson() &#123; super("None"); &#125; public String toString()&#123;return "NullPerson";&#125; &#125; public static final Person NULL = new NullPerson();&#125;Person p;if(p == null)&#123; p = Person.NULL;&#125; 总结 RTTI 允许通过匿名基类的引用来发现类型信息。但是使用多态会更好。 必须注意的是，不要太早的关注程序的效率问题，这是个诱人的陷阱，最好先让程序运作起来，然后再考虑它的速度，如果要解决效率问题可以用profiler 反射允许更加动态的编程风格]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>书籍笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入浅出笔记（END）]]></title>
    <url>%2F2018%2F08%2F03%2Fjs-srqc-note-end%2F</url>
    <content type="text"><![CDATA[OOP因为JavaScript是弱类型，没有直接的机制去实现参数的重载，在JS中函数传参类型不确定，个数也是任意的，可以通过判断实际传入参数的个数，去模拟重载 12345678910111213141516function Person()&#123; var args = arguments; if(typeof args[0] === 'object' &amp;&amp; args[0])&#123;//因为null也是object if(args[0].name)&#123;this.name = args[0].name;&#125; if(args[0].age)&#123;this.age = args[0].age;&#125; &#125;else&#123; if(args[0])&#123;this.name = args[0];&#125; if(args[1])&#123;this.age = args[1];&#125; &#125;&#125;Person.prototype.toString = function()&#123; //重写toString方法 可以调用 return this.name+""+this.age;&#125; var bosn1 = new Person('Bson',27);//传入两个参数var bson2 = new Person(&#123;name:‘N',age:12&#125;); //传入一个对象 调用基类 12345678910111213function Person(name)&#123;this.name = name;&#125;function Student(name,className)&#123; this.className = className; Person.call(this,name); //调用基类的构造器&#125;var bosn = new Student('Bson','ABC');bson; //Student&#123;className:"ABC",name:"Bosn"&#125;Person.prototype.init = function()&#123;&#125;;Student.prototype.init = function()&#123; //do sth... Person.prototype.init.apply(this.arguments); //调用基类的方法&#125;; 模块化 123456789101112131415161718var moduleA;moduleA = function()&#123; var prop = 1; function func()&#123; return &#123; func:func, prop:prop &#125; &#125;&#125;();var moduleA;moduleA = new function()&#123; var prop = 1; function func()&#123;&#125; this.func = func; this.prop = prop;&#125;; 实践-探测器立即执行的匿名函数，防止变量、函数声明这些泄露到外部 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556!function(global)&#123; // 匿名函数 最外层只传了this 一般模式下 会指向全局对象 function DetectorBase(configs)&#123; //探测器基类 if(!this instanceof DetectorBase)&#123;//为了不让外部通过直接调用的方式调用 throw new Error('Do not invoke without new'); &#125; this.configs = configs;//配置 this.analyze(); //解析数据 &#125; DetectorBase.prototype.detect = function()&#123; //模板方法 探测 throw new Error("Not implemented");// 必须实现这个方法否则报错 抽象 &#125;; DetectorBase.prototype.analyze = function()&#123; console.log('analyzing.....'); this.data = "DATA...."; &#125;; function LinkDetector(links)&#123; //链接探测器 if(!this instanceof LinkDetector)&#123;//同样必须使用new去构造 throw new Error('Do not invoke with new.'); &#125; this.links = links; DetectorBase.apply(this,arguments); //调用基类的构造器 &#125; inherit(LinkDetector,DetectorBase); //实际原型链的继承 //LinkDetector.prototype.xxx = xxx ; 再扩展,继承时会改写prototype属性 function inherit(subClass,superClass)&#123; subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; &#125; LinkDetector.prototype.detect = function()&#123; //子类重写detect方法 console.log("Loading data: "+this.data); console.log("Scaning links: "+this.links) &#125; //防止被修改 Object.freeze(DetectorBase); Object.freeze(DetectorBase.prototype); Object.freeze(LinkDetector); Object.freeze(LinkDetector.prototype); //导出到全局对象 global就是全局对象 definProperties属性都是false Object.defineProperties(global,&#123; LinkDetector:&#123;value:LinkDetector&#125;, DetectorBase:&#123;value:DetectorBase&#125; &#125;);&#125;(this);var ld = new LinkDetector('http://www.baidu.com http://www.qq.com');//analyzing.....ld.detect();//Loading data: DATA....//Scaning links: http://www.baidu.com http://www.qq.com 正则表达式1234/\d\d\d/.test("123"); //truenew RegExp("Bson").test("Hi,Bson"); //true RegExp("Bson").test("Hi,Bson"); //true 格式 意义 Demo(return true) . 任意字符（除换行符） /…/.test(‘1a@’); \d 数组0-9 /\d\d\d/.test(“123”); \D 非\d:不是数字0-9的字符 /\D\D\D/.test(“ab!”); \w 0-9,A-Z,a-z,_ /\w\w\w/.test(“aB9_”); \W 非\w /\W\W\W/.test(“@!$”); \s 空格符、TAB、换页符、换行符 /\sabc/.test(“ abc”); \S 非\s \t \r \n \v \f tab 回车 换行 垂直制表符 换页符 范围符号 意义 Demo [...] 字符范围 [a-z] [0-9] [A-Z0-9a-z_] [^...] 字符范围以外 [^a-z] [^abc] ^ 行首 ^Hi $ 行尾 test$ \b 零宽单词边界 \bno \B 非\b ** 右斜线 \ 转义** 分组 格式 意义 Demo(return true) (x) 分组，并记录匹配到的字符串 /(abc)/ \n 表示使用分组符(x)匹配匹配到的字符串 /(abc)\1/.test(&#39;abcabc&#39;) (?:x) 仅分组不引用 /(?:abc)(def)\1/.test(&#39;abcdefdef&#39;) 重复 格式 意义 Demo x* x+ *&gt;=0 +&gt;0 贪婪算法 abc* —&gt; ab、abc、abcc abc+ —&gt; abc、abcc x*? x+? 同x* x+ 非贪婪算法(少) abcccc -&gt; abc*? 匹配ab,abc+? 匹配abc x? 出现0或者1次 `x y` x或者y x{n} x{n,} x{n,m} 重复n次 重复&gt;=n次，重复次数满足n&lt;=x&lt;=m 三个Flag global 匹配所有的情况 —— g ignoreCase 不区分大小写 —— i multiline 有分行跨行时 —— m12/abc/gim.test("ABC"); //trueRegExp("abc","gim"); 对象属性 1234/abc/g.global //true/abc/g.ignoreCase //false/abc/g.multiline //false/abc/g.source //"abc" 正则的内容 对象方法 1234567/abc/.exec("abcdef"); //"abc" 匹配/abc/.test("abcde"); //true/abc/.toString(); // "/abc/"var reg = /abc/;reg.compile("def"); //改变正则的属性ref.test("def"); //true string类型与正则相关的方法 1234String.prototype.search "abcabcdef".search(/(abc)\1/); //0String.prototype.replace "aabbbbcc".replace(/b+?/,"1"); //aa1bbbccString.prototype.match "aabbbbccbb".match(/b+/g);//["bbbb","bb"] g匹配完String.prototype。split "aabbbbccbbaa".split(/b+/);//["aa","cc","aa"]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>视频笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想笔记（三）]]></title>
    <url>%2F2018%2F08%2F02%2Fjava-bcsx-note-3%2F</url>
    <content type="text"><![CDATA[持有对象123456Collection&lt;Integer&gt; c1 = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,3,4)); c1.addAll(Arrays.asList(5,6));Collections.addAll(c1, 7,8); //这种方式比Arrays.asList快的多List&lt;Integer&gt; l = Arrays.asList(1,2,3,4); //底层是数组 不是ArrayList 没有add方法 与HashSet一样，HashMap也提供了最快的查找技术，也没有按照任何明显的顺序来保存其元素。TreeMap按照比较结果升序保存键，而LinkedHashMap则按照插入顺序保存键，同时保留了HashMap的查询速度。 List ArrayList 访问快，读写较慢LinkedList 访问较慢，读写快，特征集比ArrayList大。 方法 当使用remove()或者removeAll()方法使用参数是值时，会依赖于equals()方法 toArray()方法可以将任意一个Connlection转换为一个数组，无参数将返回一个Object[],如果你传递目标类型的数据，它将产生指定类型的数据，参数大小不会限制数组长度。 1234Collection&lt;Integer&gt; c1 = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,3,4)); Integer[] i = c1.toArray(new Integer[0]);//如果不加参数 不能强转成Integer[] 只能返回Object[] System.out.println(i.length); //4 LinkedList有使其作为 栈、队列、双端队列 的方法 迭代器 迭代器是一个对象，它的工作是遍历并选择系列中对象，客户端程序员不必指定或关系该系列的底层结构。此外，迭代器常常被成为轻量级对象：创建它的代价小。因此，经常可以见到对迭代器有些奇怪的限制，例如，Java的Iterator只能单向移动，这个Iterator只能用于： 使用方法iterator()要求返回一个Iterator。Iterator将准备好返回序列的第一个元素。 使用next()获得序列中的下一个元素。 使用hasNext()检查序列中是否还有元素。 使用remove()将迭代器新近返回的元素删除。 ListIterator ListIterator是一个更加强大的Iteraor的子类型，它只能用于各种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问的最后一个元素。 123456789List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList("a","b","c")); ListIterator&lt;String&gt; it = list.listIterator(); while(it.hasNext())&#123; System.out.println(it.next()+"-"+it.nextIndex()+"- "+it.previousIndex()); &#125;/* a-1-0 b-2-1 c-3-2 */ 栈 “栈”通常是指“后进先出”(LIFO) 12345678//使用LinkedList能够直接实现栈的所有功能方法，尽管已经有了java.util.Stack。//但是LinkedList可以产生更好的Stackclass Stack&lt;T&gt;&#123; private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void push(T v)&#123;storage.addFirst(v);&#125; //存元素 存在第一位 public T peek()&#123;return storage.getFirst();&#125; //获取元素 第一位 栈顶元素 public T pop()&#123;return storage.removeFirst();&#125; //删除元素 删除第一位&#125; Set Set不保存重复的元素。查找是Set中最重要的操作，因此你通常都会选择一个HashSet的实现，它专门对快速查找进行了优化。Set具有与Collection完全一样的接口，因此没有任何额外的功能，只是行为不同。Set是基于对象的值来确定归属性的HashSet使用的是散列函数TreeSet使用的是红-黑数LinkedHashSet因为查询速度原因也使用了散列，链表维护插入顺序//书中232页写的LinkedHashList我并在jdk8中看见，只有LinkedHashSet和LinkedHashMap，应该是笔误 Map 将对象映射到其它对象的能力是一种解决编程问题的杀手锏。 12345678//统计随机数的次数Random rand = new Random(47);Map&lt;Integer, Integer&gt; m = new HashMap&lt;Integer,Integer&gt;();for (int i = 0; i &lt; 20; i++) &#123; int r = rand.nextInt(20); m.put(r, m.get(r) == null ? 1: m.get(r)+1);&#125;System.out.println(m.toString()); Queue 队列是一个典型的先进先出(FIFO)的容器。LinkedList提供了方法以支持队列的行为，并且它实现了Queue接口，因此LinkedList可以用作Queue的一种实现。Queue queue = new LinkedList() PriorityQueue 优先级队列 它可以确保你调用 peek() 、poll()、remove() 方法时，获取的元素将是优先级最高的。 foreach 与 迭代器 Iterator接口被foreach用来在序列中移动。因此如果你创建了任何实现Iterator的类，都可以将它用于foreach语句中。大量的类都是Iterator的类型，包括所有的Collection类(但是不包括各种Map，但是由entrySet()产生的Map.Entry的元素构成的是Set，keySet()也是返回Set)。数组到 Iterator 不会把基本类型自动转换成包装类。必须手动转换。 总结 容器不能持有基本类型，但是自动包装机制会仔细地执行基本类型到到容器中所持有的包装类型之间的双向转换。 新程序中不应该使用过时的Vector、Hashtable、Stack. List可以生成listIterator也可以生成Iterator 除了TreeSet之外的所有Set都拥有与Colleaction完全一样的接口。 字符串12345678public class Concatenation&#123; public static void main(String[] args)&#123; String s1 = "asdf"; String s2 = "qwe"+s1+"ert"+47; System.out.println(s2); &#125;&#125;//qweasdfert47 1234567891011121314151617181920212223242526272829303132//反编译如下 简化部分注解C:\Users\Administrator\Desktop&gt;javap -c ConcatenationCompiled from &quot;Concatenation.java&quot;public class Concatenation &#123; public Concatenation(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String asdf 2: astore_1 3: new #3 // class StringBuilder 6: dup 7: invokespecial #4 // Method StringBuilder.&quot;&lt;init&gt;&quot;:()V 10: ldc #5 // String qwe 12: invokevirtual #6 //Method StringBuilder.append:(LString;) 15: aload_1 16: invokevirtual #6 // Method StringBuilder.append:(LString;) 19: ldc #7 // String ert 21: invokevirtual #6 // Method StringBuilder.append:(LString;) 24: bipush 47 26: invokevirtual #8 // Method StringBuilder.append:(I) 29: invokevirtual #9 // Method StringBuilder.toString:() 32: astore_2 33: getstatic #10 // Field System.out:Ljava/io/PrintStream; 36: aload_2 37: invokevirtual #11 // Method PrintStream.println:(LString;)V 40: return&#125; 从反编译可以看到，编译器自动引入了java.lang.StringBuilder类。因为它更加高效。编译器创建了StringBuilder对象，用以构造String，并为每个字符串调用一次1次StringBuilder的append()方法，总计四次。最后调用toString()方法生成结果，并存为s2(使用的命令是astore_2) 但是不要一味地想着编译器帮你优化就是最好的 123456789101112131415public String func1(String[] str)&#123; String result = ""; for(int i =0;i&lt;str.length;i++)&#123; result +=str[i]; &#125; return result;&#125;public String func2(String[] str)&#123; StringBuilder result = new StringBuilder(); for(int i =0;i&lt;str.length;i++)&#123; result.append(str[i]); &#125; return result.toString;&#125; 反编译如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public static java.lang.String func1(java.lang.String[]); Code: 0: ldc #10 // String 2: astore_1 3: iconst_0 4: istore_2 5: iload_2 6: aload_0 7: arraylength 8: if_icmpge 38 //i&lt;str.length 比较false时跳转到38行 11: new #11 // class StringBuilder 14: dup 15: invokespecial #12 // Method StringBuilder.&quot;&lt;init&gt;&quot;:()V 18: aload_1 19: invokevirtual #13 // Method StringBuilder.append:(LString;) 22: aload_0 23: iload_2 24: aaload 25: invokevirtual #13 // Method StringBuilder.append:(LString;) 28: invokevirtual #14 // Method jStringBuilder.toString:()LString; 31: astore_1 32: iinc 2, 1 35: goto 5 //回到第五行 构成一个循环 38: aload_1 39: areturn public static java.lang.String func2(java.lang.String[]); Code: 0: new #11 // class StringBuilder 3: dup 4: invokespecial #12 // Method StringBuilder.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: iconst_0 9: istore_2 10: iload_2 11: aload_0 12: arraylength 13: if_icmpge 30 16: aload_1 17: aload_0 18: iload_2 19: aaload 20: invokevirtual #13 // Method StringBuilder.append:(String;) 23: pop 24: iinc 2, 1 27: goto 10 //回到第10行，与13行构成一个循环 30: aload_1 31: invokevirtual #14 // Method StringBuilder.toString:()LString; 34: areturn&#125; 所以可以看到func1 每次循环都会新建一个StringBuilder，而func2只会新建一个StringBuilder，你还可以在代码中显示的指定其大小，以避免多次重新分配缓冲。（缓冲区(buffer)，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区，显然缓冲区是具有一定大小的。用以缓解冲击。） 如果你向走捷径，例如append(a+&quot;:&quot;+c)，那编译器就会为你创建另一个StringBuilder对象去处理括号内的字符串操作。 Java中每个类从根本上都是继承自Object。因此容器类都有toString()方法，并且重写该方法。所以在重写toString方法时一定要注意编译器的无意识的递归，当你在toString中使用this操作的时候，当你需要转换成String类型时，编译器会自动调用this.toString()方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>书籍笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入浅出笔记（三）]]></title>
    <url>%2F2018%2F08%2F02%2Fjs-srqc-note-3%2F</url>
    <content type="text"><![CDATA[闭包&amp;作用域理解闭包 闭包是指 有权访问另一个函数作用域中的变量的 函数，闭包是定义在一个函数内部的函数 12345678910documnt.body.innerHTML = "&lt;div id=div1&gt;aaa&lt;/div&gt;"+"&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;";for(var i = 1;1&lt;4;i++)&#123; !function(i)&#123; //匿名函数的一个写法，可以选择加括号或者感叹号 document.getElementById('div'+i). addEventListener('click',function()&#123; alert(i); &#125;); //1,2,3 &#125;(i); //不加这个函数的话 点击弹出总是4&#125; ** 变量的作用域 ** 函数内部可以直接读取全局变量。 函数外部自然无法读取函数内的局部变量。 函数内部声明变量，一定要使用var命令。如果不用，你实际上声明了一个全局变量！ ** 如何从外部读取局部变量？** Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 ** 闭包的用途 ** 可以读取函数内部的变量 让这些变量的值始终保持在内存中。 12345678910111213141516function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; //没有加var的全局匿名函数nAdd,匿名函数本身就是一个闭包 function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1(); //返回的f2被赋给了一个全局变量,这导致f2始终在内存中，而f2的存在依赖于f1，//因此f1也始终在内存中，不会在调用结束后，//被垃圾回收机制（garbage collection）回收。result(); // 999 nAdd(); result(); // 1000 闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 作用域 全局、函数、eval 三个作用域 没有块级作用域 ES3 执行上下文JS解释器如何找到我们定义的函数和变量？ 变量对象(Variable Object，VO) 是有一个抽象概念中的“对象”，它用于存储执行上下文中的：1. 变量 2. 函数声明 3. 函数参数 JS解释器初始化 VO上下文 1234567891011121314VO(globalContext) === [[global]];[[global]] = &#123; Math : &lt;&gt;, String : &lt;&gt;, isNaN : function()&#123;[Native Code]&#125; ... window : global&#125;;GlobalContextVO (VO === this === global)String(10); //[[global]].String(10);window.a = 10; //[[global]].window.a = 10;this.b = 20; //[[global]].b = 20; 函数中的激活对象 AO 123456789VO(functionContext) === AO;AO = &#123; arguments : &lt;Arg0&gt;&#125;;arguments = &#123; callee, length, properties-indexes&#125;; VO按照如下顺序填充 1. 函数参数（若为传入 ，初始化该参数值为undefined） 2. 函数声明（若发生命名冲突，会覆盖） 3. 变量声明（初始化变量值为undefined，若发生命名冲突，会忽略。） 12345678910111213141516function test(a,b)&#123; var c = 10; //赋值语句 不是变量初始化阶段做的 function d()&#123;&#125; var e = function _e()&#123;&#125;; //函数表达式名 _e 不会影响VO (function x()&#123;&#125;); b = 20; //变量声明冲突会被忽略&#125;test(10);AO(test)=&#123; a:10, b:undefined, c:undefined, d:&lt;ref to func "d"&gt; e:undefined&#125;; / 函数声明 函数表达式 函数构造器 前置 ✔ 允许匿名 ✔ ✔ 立即调用 ✔ ✔ 通过函数名访问 ✔ 没有函数名 ✔ OOP概念与继承封装、继承、多态、抽象 12345678910function Foo()&#123;&#125;typeof Fpp.prototype; //"Object"Foo.prototype.x = 1;Foo.prototype&#123; constructor : Foo, __proto__ : Object.prototype, x : 1&#125; 1234567891011121314151617181920212223242526272829303132333435function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype.hi = function()&#123; console.log('hi'+this.name+"i'm"+this.age);&#125;Person.prototype.LEGS_NUM = 2;Person.prototype.ARMS_NUM = 2;Person.prototype.walk = function()&#123; console.log(this.name + " is walking...");&#125;function Student(name,age,className)&#123; Person.call(this,name,age); this.className = className;&#125;Student.prototype = Object.create(Person.prototype);//创建一个空对象 它的原型指向它的参数 如果不用create直接= 两个prototype就绑定一起了Student.prototype.constructor = Student;//保证一致性 如果不设置的话 会依据Person.prototype 指向PersonStudent.prototype.hi = function()&#123; //覆盖 console.log('hi,'+this.name+",i'm"+this.age+",from"+this.className);&#125;;Student.prototype.learn= function(subject)&#123; console.log(this.name + " is learning " +subject);&#125;var bosn = new Student('Bosn',27,'Class3');bosn.hi(); // hi,Bosn,i'm27,fromClass3bson.LEGS_NUM; //2bosn.walk();//Bosn is walking...bosn.learn('math');//Bosn is learning math 原型链如下图 *并不是所有的函数都会继承至Object.prototype *var o = new Obejct(null) o.__proto__; //undefined prototype属性123456789101112Student.prototype.x = 101;bosn.x; //101Student.prototype = &#123;y:2&#125;; //prototype 指向了一个新的对象&#123;y:2&#125;bosn.y; //undefined //但是bosn上的prototype并没有改变指向 还是指向的原来的对象bosn.x; // 101bosn.__proto__;//Object &#123; constructor: Student(), hi: hi(), leran: leran(), x: 101 &#125;var n = new Student('v',1,'s');n.x; // undefinedn.y; //2 instanceof 左边一般要求是一个对象，右边要求是一个函数或者说是构造器，它会判断右边构造器的prototype的属性是否出现在左边对象的原型链上。 所有右边必须是一个函数对象，不是函数的话 就没有prototype属性 就会报错。12[1,2] instanceof Array === truenew Obejct() instanceof Array === false 实现继承的多种方式1234567891011121314151617function Person()&#123;&#125;function Student()&#123;&#125;[x] Student.prototype = Person.prototype; //1 改变Student.prototype的同时也会改变Person.prototype[x] Student.prototype = new Person();//2 因为调用了Person的构造函数新建了一个实例，若是Person需要传参 则会很奇怪[√] Student.prototype = Object.create(Person.prototype);//3 Student.prototype 修改不会影响到 Person.prototype 但是ES5之后才支持ES5之前模拟 相当于1+2的结合if(!Object.create)&#123; Object.create = function(prroto)&#123; function F()&#123;&#125; F.prototype = proto; return new F; &#125;;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>视频笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入浅出笔记（二）]]></title>
    <url>%2F2018%2F07%2F31%2Fjs-srqc-note-2%2F</url>
    <content type="text"><![CDATA[数组JS中的数组是弱类型的，数组中可以含有不同的类型元素 字面量数组创建 var BAT = [&#39;B&#39;,&#39;A&#39;,&#39;T&#39;]; 数组允许最后一个值后留一个逗号 new Array 创建数组 var arrLength = new Array(100); //undefined * 100 var BAT= new Array(&#39;B&#39;,&#39;A&#39;,&#39;T&#39;); 数组的读写1234567891011121314151617var arr = [1,2,3,4,5];arr[1]; //2arr.lengthl; //5arr[5] = 6;arr.length; //6delete arr[0];arr[0]; //undefinedarr.length; //61 in arr; //false delete删除的没有这个keyarr[arr.length] = 7; // equal to arr.push(7);在尾巴添加arr.unshift(0); //在头添加arr.pop(); //equal to arr.length -= 1; 在尾部删除元素arr.shift(); //在头部删除一个元素 数组是动态的不用指定大小 二维数组 &amp; 稀疏数组1var arr = [[0,1],[2,3],[4,5]]; 稀疏数组并不含有从0开始的连续索引，一般length属性值比实际元素个数大。 1234var arr1 = [undefined];0 in arr1; //truevar arr = [,,];0 in arr; //false 数组方法12&#123;&#125; =&gt; Object.prototype[] =&gt; Array.prototype 1234567891011121314Array.prototype.joinArray.prototype.reverseArray.prototype.sortArray.prototype.concatArray.prototype.slice //切片Array.prototype.splice //交接Array.prototype.forEach(ES5)Array.prototype.map(ES5)Array.prototype.filter(ES5)Array.prototype.every(ES5)Array.prototype.some(ES5)Array.prototype.reduce/reduceRight(ES5)Array.prototype.indexOf/lastindexOf(ES5)Array.isArray(ES5) join 数组转字符串 1234var arr = [1,2,3];arr.join(); //"1,2,3"arr.join("_"); // "1_2_3"new Array(4).join("a"); //"aaa" reverse 数组逆序 123var arr = [1,2,3;arr.reverse(); //[3,2,1]arr; // [3,2,1] sort 排序（默认是按字母排序） 12345678910111213141516var arr = ["a","d","b","c"];arr.sort(); //[ "a", "b", "c", "d" ] arr; 原数组被修改arr = [13,24,51,3];arr.sort();//[ 13, 24, 3, 51 ]arr.sort(function(a,b)&#123; return a - b; //升序&#125;); //[ 3, 13, 24, 51 ]arr = [&#123;age:25&#125;,&#123;age：39&#125;，&#123;age:99&#125;];arr.sort(function(a,b)&#123; return a.age - b.age; &#125;);arr.forEach(function(item)&#123; console.log('age',item.age);&#125;) concat 数组合并 12345var arr = [1,2,3];arr.concat(4,5); //[1,2,3,4,5]arr; //[1,2,3] 原数组未被修改arr.concat([10,11],13); //[1,2,3,10,11,13]arr.concat([1,[2,3]]); //[1,2,3,1,[2,3]]; slice 返回部分数组 123var arr = [1,2,3,4,5];arr.slice(1,3);//[2,3]arr.silce(1,-1);//[2,3,4] splice 数组拼接 1234567891011var arr = [1,2,3,4];arr.splice(2); // returns [3,4]arr; //[1,2] 原数组修改arr = [1,2,3,4,5];arr.splice(2,3); //returns [3,4]arr;//[1,2,5]arr = [1,2,3,4,5];arr.splice(1,1,'a','b'); //returns[2]arr; //[1,"a","b",3,4,5] forEach 数组遍历 123456789var arr = [1,2,3];arr.forEach(function(x,index,a)&#123; //值,索引,指向数组本身 console.log(x+'|'+index+'|'+a);&#125;)/*1|0|1,2,32|1|1,2,33|2|1,2,3*/ map 数组映射 12345var arr = [1,2,3];arr.map(function(x)&#123; return x+10;&#125;);//[11,12,13]arr; //[1,2,3] 不会修改原数组 filter 数组过滤 12345var arr = [1,2,3,4];arr.filter(function(x,index)&#123; return x%2 === 0 &amp;&amp; index&lt;3;&#125;); // [2]arr; // [1,2,3,4] 不会修改原数组 every &amp; some 数组判断 1234var arr = [1,2,3,4];arr.every(function(x)&#123; return x&lt;10;&#125;);//true 必须每一个值都满足才返回true 而some只需要一个元素满足即可 reduce &amp; reduceRight 数组聚合成结果数组两两之间做一个操作 123456789101112var arr = [1,2,3];var sum = arr.reduce(function(x,y)&#123; return x+y;&#125;,0); //6 第二个元素 0 是一个可选参数 当填进去的时候 函数第一次第一个参数 x = 0 // y=1 ， 第二次 x 是第一次的返回值 y =2arr;//[1,2,3]arr = [3,9,6];var max = arr.reduce(function(x,y)&#123; console.log(x+"|"+y); return x&gt;y?x:y;&#125;);//3|9 9|6max;//9 reduceRight 是从数组的尾巴开始遍历 indexOf &amp; lastIndexOf 数组检索 1234567var arr= [1,2,3,2,1];arr.indexOf(2);//1 查找元素2的下标arr.lastIndexOf(2);//3arr.indexOf(22); //-1 没有这个元素arr.indexOf(1,1);//4 从下标为1的元素开始查找1 arr.length(1,-3); //4arr.indexOf(2,-1); //-1 lastIndexOf 是从数组的尾巴开始查找 Array.isArray 判断是否为数组 12345Array.isArray([]); // true[] instanceof Array;// true(&#123;&#125;).toString.apply([]) === '[object Array]'; //true[].constructor === Array; //true 数组小结数组 VS 一般对象 相同 都可以继承 数组是对象，对象不一定是数组 都可以当做对象添加删除属性 不同 数组自动更新length 按索引访问数组常常比访问一般对象属性明显迅速 数组对象继承Array.prototype上的大量数组操作方法 字符串和数组 字符串是类数组123456var str = "hello";str.charAt(0); //"h"str[1]; //eArray.prototype.join.call(str,"_");//"h_e_l_l_o" call将对象装化为数组 函数和作用域函数概述 函数是一块JavaScript代码，被定义一次，但可执行和调用多次。JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递所以我们也常叫JS中的函数为函数对象。一般函数调用若是没有return 语句这会返回undefined若是作为构造器外部使用new调用，若是没有return 或者是return 基本类型则会返回this 声明与表达式 创建函数有不同的方式，常见的两种就是函数声明function add(){}函数表达式 1234var add = function()&#123;&#125;; (function()&#123;&#125;)(); //立即执行函数表达式 函数声明不能立即调用return function()&#123;&#125;; //函数表达式作为返回值var add = function foo()&#123;&#125;; //命名式函数表达式 区别 函数声明会被前置，函数表达式只会变量声明提前 命名函数表达式 12345var func = function nfe()&#123;&#125;; //可以在调试的时候显示函数名 否则会显示[anomyous function]func === nfe;//IE6~8 false ,IE9+ 'nfe' is undefined//递归调用var func = function nfe()&#123;nfe();&#125; Function构造器 12345678910111213141516171819// 没有函数字 只能匿名 不会前置//表示a和b有两个形参 var func = new Function('a','b','console.log(a+b);');func(1,2); //3//这两种没有区别var func = Function('a','b','console.log(a+b);');func(1,2); //3Function('var localVal = "local";console.log(localVal);')();//立即执行console.log(typeof localVal); //拿不到Function中定义的localVal//local undefined var globalVal = 'global';(function()&#123; var localVal = 'local'; Function('console.log(typeof localVal,typeof globalVal);')()&#125;)();// undefined string // 可以拿到全局变量globalVal 但是拿不到外层的局部变量localVal this全局的this(浏览器) 1234this.document === docuemnt //truethis === window //truethis.a = 37; //全局变量awindow.a //37 一般函数this 12345678910function f1()&#123; return this;&#125;f1() === window;//ture | global objectfunction f2()&#123;"use strict";return this;&#125;f2() === undefined; //true 作为对象方法的函数this 是最常见的用法 123456789101112131415161718192021var o = &#123;prop :37&#125;;function func()&#123;return this.prop;&#125;o.f = func;o.f(); //37//原型链上的thisvar o = &#123;f:function()&#123;return this.a+this.b;&#125;&#125;;var p = Object.create(o);p.a = 1;p.b = 4;p.f(); //5//call/apply方法add.call(o,1,2); //第一个参数作为this传给add方法//bind方法 ES5提供的方法 IE9+function f()&#123;return this.a;&#125;var g = f.bind(&#123;a:"test"&#125;); //把对象绑定作为this传入fg(); //testvar o = &#123;a:37,f:f,g:g&#125;;o.g +"" o.g //37 "test" 函数属性&amp;arguments123456789function foo(x,y,z)&#123; arguments.length; //2 实参个数 arguments[0] = 10; //非严格下形参x可以改变 arguments[2] = 10; //没有参数传进来 则无论如何都会影响 arguments.callee === foo; //true 非严格下才能用&#125;foo(1,2);foo.length; //3 形参个数foo.name; //foo bind与currying 改变this的指向 函数柯里化 1234567891011121314this.x = 10;var m = &#123;x:100,getX:function()&#123;return this.x;&#125;&#125;;m.getX(); //100var getX = m.getX();getX(); //10var bindGetX = getX.bind(m);bindGetX(); //100function add(a,b,c)&#123;return a+b+c&#125;var func = add.bind(undefined,100); //第一次绑定 固定a=100func(1,2); //103var func2 = func.bind(undefined,200); //第二次绑定 固定b = 200func2(10); //310]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>视频笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想笔记（二）]]></title>
    <url>%2F2018%2F07%2F27%2Fjava-bcsx-note-2%2F</url>
    <content type="text"><![CDATA[访问权限控制package语句，必须是文件中除注释以外的第一句程序代码。需注意的是，Java包的命名规则全部使用小写字母，包括中间的字也是如此。 import static com.PackName.xxClass.* 语句可以让你在代码中直接使用静态的导入方法 内部类可以用任何一种访问修饰符修饰 控制对成员的访问权限有两个原因。 1. 是为了使用户不接触它们不该接触的部分，同使也简化客户端开发对于类的理解。 2. 确保不会有任何客户端开发依赖于某个类的底层实现的任何部分 复用类继承与组合为了继承，一般规则是将所有的数据成员都指定为private，将所有的方法指定为public。 若是父类有带参构造器需要用supen(args)显示调用 组合技术通常用于想在新类中使用现有类的功能而非接口 （ has - a 有一个）继承则是使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。（ is - a 是一个）是否使用继承考虑是否需要从新类向基类向上转型 总结 开始一个设计时，一般应优先选择使用组合（或者可能是代理），只有确实必要时才用继承。因为组合更加灵活。此外，通过对成员类型使用继承技术的添加技巧，可以在运行时改变那些成员对象的类型和行为。当你开始设计一个系统时，应该认识到程序开发是一种增量过程，犹如人类的学习一样，这一点很重要。程序依赖于实验，你可以尽可能去分析，但当你开始执行一个项目时，你任然无法知道所有的答案。如果将项目视作是一种有机的、进化着的生命体而去培养，而不是打算盖摩天大楼一样快速见效，就会获得更多和更迅速的回馈。继承和组合正是在面向对象程序设计中使你可以执行这种实验的最基本的两个工具。 final 关键字通常它指“这是无法改变的”，可能出于这两种理由：设计或者效率。一般可能使用到final的三种情况：数据、方法、类。 final 数据有时数据的恒定不变是很有用的，比如： 一个永不改变的编译时的常量。 一个在运行时被初始化的值，而你不希望它被改变。编译器可以将常量代入任何可能用到它的计算式中，也就是说，可以在编译时执行计算式。这减轻了一些运行时的负担。在Java中这类常量必须是基本数据类型，并且以关键字final表示。在对常量进行定义的时候，必须对其进行赋值。一个既是static又是final的域只占据一段不能改变的存储空间。当对象引用不是基本数据类型使用final时，对于对象引用，使其引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它改为另一个对象。然而，对象其自身却是可以被修改的，Java并没有提供使任何对象恒定不变的途径（但可以自己编写类是取得恒定不变的效果）。数组也一样，它也是对象。 根据惯例，static 、final 同时修饰的域（编译期常量）将用大写表示。字间用下划线隔开。 Java允许生成“空白final”，但编译器需确保空白final在使用前必须被初始化。必须在域的定义处或者每个构造器中用表达式对final进行赋值,final 也可用在参数中，这一特性主要用于匿名内部类传递数据。 1234567public class t1 &#123; private final int j = 2; private final int i; t1(final int a)&#123; i = a; &#125;&#125; final 方法使用final方法的原因有两个 把方法锁定，防止继承类修改它的含义。这是出于设计的考虑，确保在继承中使方法行为保持不变，并且不会被覆盖。 效率。&lt;Java SE5/6 上的版本中已经不再需要了&gt; 类中所有的private方法都隐式的指定为是final的。由于无法取用private方法，所以也就无法覆盖它。可以给private方法添加final修饰，但这并没有添加任何额外的意义。 final 类当将某个类的整体定义为final时，就表明了你不打算继承该类，而且也不允许别人这么做。换句话说，出于某种考虑，你对该类的设计永不需要做任何改动，或者出于安全考虑，你不希望它有子类。** 由于final类是禁止继承的，所以final类中的所有方法都隐式的指定为是final的，因为无法覆盖他们 ** 有关final的忠告在设计类时，将方法指明是final的，应该说是明智的。 多态 多态的作用则是消除类型之间的耦合关系通过动态绑定实现多态所做的代码修改，不会对程序中其它不应受影响的部分产生破坏只有非private方法才可以覆盖 构造器内部的多态行为 12345678910111213141516171819202122232425262728class Person1&#123; void eat()&#123;System.out.println("eat.eat.eat..");&#125; Person1()&#123; eat(); &#125;&#125;class Student1 extends Person1&#123; private int eatNum = 4; Student1(int eatNum)&#123; this.eatNum = eatNum; System.out.println("Student1.Student1.eatNum="+eatNum); &#125; @Override void eat() &#123; System.out.println("Student1.eat.eatNum="+eatNum); &#125;&#125;public class t1 &#123; public static void main(String[] args) &#123; new Student1(3); &#125;&#125;/*Output:* Student1.eat.eatNum=0* Student1.Student1.eatNum=3*/ 为啥第一个等于0？ 初始化的实际过程是： 在其它任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。 基类构造器调用的是子类覆盖的 eat() 方法，由于1的原因 eatNum = 0 按照声明的顺序调用成员的初始化方法 调用子类的构造器主体 编写构造器的准则 用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其它方法 接口使用接口的核心原因： 为了向上转型为多个基类型（以及由此带来的灵活性）。 与使用抽象基类相同，防止客户端创建该类的对象 如果某事物应该成为一个基类，那么第一选择应该是使它成为一个接口。 因为重载方法仅通过返回值是分不开的，所以若是在覆盖实现接口方法中方法仅返回值不同则会发生混乱，编译器会报错。 在Java SE5 之前通常使用接口来定义常量，因为你放入接口中的任何域都自动隐式是static和final的。之后使用更为强大的enum。 嵌套接口接口方法可以嵌套在类或者其它接口中 1234567class Obj implements A.B&#123; private interface C&#123;&#125; class InObj implements C&#123;&#125;&#125;interface A&#123; interface B&#123;&#125;&#125; 接口与工厂接口是实现多重继承的途径，而生成遵循某个接口的对象典型方式就是工厂方法设计模式。这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。 123456789101112131415161718192021222324252627public class SimpleFactory &#123; public Product createProduct(int type)&#123; switch (type) &#123; case 1: return new ConcreteProduct1(); case 2: return new ConcreteProduct2(); default: return new ConcreteProduct3(); &#125; &#125;&#125;class Client&#123; public static void main(String[] args) &#123; SimpleFactory sf = new SimpleFactory(); Product p = sf.createProduct(1); &#125;&#125;interface Product&#123;&#125;class ConcreteProduct1 implements Product&#123;&#125;class ConcreteProduct2 implements Product&#123;&#125;class ConcreteProduct3 implements Product&#123;&#125; 内部类 可以将一个类定义放在另一个类的定义内部，这就是内部类。不止是可以名字隐藏和组织代码模式，当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。 12345678910111213141516171819202122public class t1 &#123; void f()&#123;&#125; Inner inner()&#123; return new Inner(); &#125; class Inner&#123; public t1 outer()&#123; return t1.this; //生成对外部类对象的引用 &#125; &#125; public static void main(String[] args) &#123; t1 t = new t1(); Inner in = t.inner(); in.outer().f();// || // Inner in = t.new Inner();// in.outer().f(); &#125;&#125; 在拥有外部类的对象之前是不可能创建内部类对象的，因为内部类对象会暗暗地链接到创建它的外部类对象上。静态内部类不需要。所以普通的内部类不能有static数据和static字段和static类。 内部类与向上转型 当将内部类向上转型为其基类，尤其是转型为一个接口时，内部类就有了用武之地。内部类对某个接口的实现可以完全不可见，并不可用。所得到的只是指向基类或接口的引用，所以能够很方便的隐藏实现细节。 12345678910111213141516171819public class t1 &#123; class SmallStudent implements Student&#123; private int age; SmallStudent(int age) &#123; this.age = age; &#125; &#125; public Student student(int age)&#123; return new SmallStudent(age); &#125; public static void main(String[] args) &#123; t1 t = new t1(); Student s = t.student(2); &#125;&#125;interface Student&#123;&#125; 在方法和作用域内的内部类1234567891011121314//在方法作用域的类-局部内部类public class t1 &#123; Student student(int age)&#123; class SmallStudent implements Student&#123; private int age; public SmallStudent(int age) &#123; this.age = age; &#125; &#125; return new SmallStudent(age); &#125;&#125;interface Student&#123;&#125; 也可以嵌入if等语句的作用域类 匿名内部类123456789101112131415161718public class t1 &#123; Student student(int age)&#123; return new Student() &#123; //相当于 StudentSub implements Student&#123;&#125; @Override public int getAge() &#123; return 0; &#125; public int value()&#123; return 1; &#125; &#125;; &#125;&#125;interface Student&#123; int getAge();&#125; 在这个匿名内部类中使用了默认的构造器来生成Student。如果需要参数，那么你需要创建一个带参构造器的类。new XXClass(x,y){}; jdk7 之前若是你的匿名内部类希望在类中使用其外部定义的对象，参数引用需为final为了解决生命周期不同的问题，匿名内部类备份了变量，为了解决备份变量引出的问题，外部变量要被定义成final我们匿名内部类使用final不是怕修改，是怕不能同步修改。值得注意的是，从JDK1.8开始，编译器不要求自由变量一定要声明为final，如果这个变量在后面的使用中没有发生变化，就可以通过编译，Java称这种情况为“effectively final”。 若是发生变化则无法通过编译。 1234567891011121314151617int answer = 42; // jdk8 上 不用强制使用finalThread t = new Thread(new Runnable() &#123; public void run() &#123; System.out.println("The answer is: " + answer); &#125;&#125;);int answer = 42;Thread t = new Thread( () -&gt; System.out.println("The answer is: " + answer));int answer = 42;answer ++; // don't do this !编译报错Thread t = new Thread( () -&gt; System.out.println("The answer is: " + answer) ); 结合工厂设计模式123456789101112131415161718192021public class SimpleFactory &#123; public Product createProduct(int type)&#123; switch (type) &#123; case 1: return new Product()&#123;&#125;; case 2: return new Product()&#123;&#125;; default: return new Product()&#123;&#125;; &#125; &#125;&#125;class Client&#123; public static void main(String[] args) &#123; SimpleFactory sf = new SimpleFactory(); Product p = sf.createProduct(1); &#125;&#125;interface Product&#123;&#125; 嵌套类 如果不需要内部类对象与其外围类对象之前有联系，那么可以将内部类声明为static。这通常称为嵌套类，普通的内部类不能有static数据和static字段和static类，嵌套类则可以。嵌套类不需要外围类对象，不能访问非静态的外围对象。嵌套类可以作为接口的一部分，因为放到接口中的任何类都是public 和 static 的。 为什么需要内部类？ 一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响主要解决’多重继承‘问题 12345678910class A&#123;&#125;class B&#123;&#125;class C&#123; A funA()&#123; return new A()&#123;&#125;; &#125; B funB()&#123; return new B()&#123;&#125;; &#125;&#125; 闭包与回调 闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过回调，对象能够携带一些信息，这些信息允许它在稍后某个时刻调用初始的对象。回调的价值在于它的灵活性，可以在运行时动态的决定调用什么方法通过内部类提供闭包的功能是优良的解决方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyIncrement&#123; void increment()&#123;System.out.println("other operation");&#125; static void f(MyIncrement mi)&#123;mi.increment();&#125;&#125;class Caller&#123; private Incrementable CallbackRef; public Caller(Incrementable CallbackRef) &#123; this.CallbackRef = CallbackRef; &#125; void go()&#123;CallbackRef.increment(1);&#125;&#125;interface Incrementable&#123; void increment(int i);&#125;class Callee1 implements Incrementable&#123; private int i = 0; @Override public void increment(int j) &#123; System.out.println(++i); &#125;&#125;class Callee2 extends MyIncrement&#123; //MyIncrement 已经有了一个increment方法，与 private int i =0; @Override void increment() &#123;//复写MyIncrement的increment方法 super.increment(); System.out.println(++i); &#125; private class Closure implements Incrementable&#123; //以提供返回Callee2的“钩子（hook）” @Override public void increment(int j) &#123; //复写Incrementable的increment方法 System.out.println("Another operation"); Callee2.this.increment(); //Closure使用此引用回调Callee2类 &#125; &#125; Incrementable getCallbackRef()&#123; return new Closure(); &#125;&#125;public class t1 &#123; public static void main(String[] args) &#123; Callee1 c1 = new Callee1(); Callee2 c2 = new Callee2(); MyIncrement.f(c2); Caller cr1 = new Caller(c1); Caller cr2 = new Caller(c2.getCallbackRef()); cr1.go(); cr1.go(); cr2.go(); cr2.go(); &#125;&#125; 内部类与控制框架 控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件驱动系统。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动系统。它的工作就是在事件“就绪”的时候执行事件。 内部类允许 控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装起来。内部类用来表示解决问题所必需的各种不同的action()。 内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变得笨拙。 内部类的继承 因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类时必须显示的用语法来明确他们之间的关系内部类不会因外部类被继承而被覆盖 123456789public class T1 &#123; class T2&#123;&#125;&#125;class T3 extends T1.T2&#123; T3(T1 t1) &#123; t1.super(); &#125;&#125; 局部内部类和匿名内部类具有相同的行为和能力，且局部内部类的名字在方法外是不可见的。使用区别则是：我们需要一个已命名的构造器，或这需要重载构造器，而匿名内部类只能用于实例化。另一个原因是，需要不止一个该内部类的对象。内部类标识符 ：外围类名+$+内部类名+.class若是匿名内部类则会把内部类名变成一个简单的数字]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>书籍笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入浅出笔记（一）]]></title>
    <url>%2F2018%2F07%2F27%2Fjs-srqc-note-1%2F</url>
    <content type="text"><![CDATA[大纲视频链接 数据类型 表达式和运算符 语句 对象 数组 函数 this 闭包 OOP 正则与模式匹配 数据类型 弱类型的特性，隐式转化逻辑 12332+32 //64"32"+32 //"3232" 字符串拼接"32"-32 //0 六种数据类型 原始类型（number string boolean nulll undefined）没有属性和方法 + 对象 object（Date Array Function ...） 严格等于（ ===） 1、类型不同，返回false 2、类型相同等于（ == ） 1、类型相同，同 === 2、类型不同，尝试类型转化和比较 1234null ==undefined -&gt; truenumber == string 转number -&gt; 1== "1.0" trueboolean == ? 转number -&gt; 1==true trueobject == number | string 尝试对象转基本类型 new String("hi") == 'hi' true 其他：false 包装对象 12345var a = "string";a.length; //6 //js会智能的把基本类型转为对应的包装对象 相当于new String 随后临时对象会被销毁a.t =3;a.t; //undefind 类型检测 12345typeof //最常见的 适合是不是函数对象和基本类型的判断 例外：typeof null === "object" instanceof //适合对象类型判断 obj instanceof Object [1,2] instanceof Array === true new Obejct() instanceof Array === false 任何一个构造函数都会有一个prototype对象属性，这个对象属性将用作new来构造出对象的原型，会维持一个原型链（Obj.proto.proto…继承关系），需注意是不同Window或iframe间的对象类型检测不能使用instanceof，检测都是false 123Object.prototype.toString.apply([]); === "[object Array]"; Object.prototype.toString.apply(null); === "[object Null]"; IE6/7/8 Object.prototype.toString.apply(null); === "[object Object]"; 其它 constructor 、 duck type JavaScript表达式与运算符 表达式是一种JS短语，可使JS解释器用来产生一个值 运算符逗号运算符它会从左到右依次去计算表达式的值最后取最右边的 1var val = (1,2,3); //val = 3 delete 运算符删除对象上的属性 12345678910111213var obj = &#123;x:1&#125;;obj.x; //1delete obj.x;obj.x; //undefined//从IE9开始var obj = &#123;x:1&#125;;//并不是对象上的所有属性都可以被delete掉的Object.defineProperty(obj,'x',&#123; configurable:false, value:1&#125;)delete obj.x; // falseobj.x; //1 in 运算符 12obj.x = 1;'x' in obj; //true new 运算符 123456function Foo()&#123;&#125;Foo.prototype.x = 1;var obj = new Foo();obj.x; //1obj.hasOwnProperty('x'); //false 判断'x'属性是原型链上的还是对象本身上的obj.__proto__.hasOwnProperty('x'); //true this 运算符 12345this; // window(浏览器)var obj = &#123; func:function()&#123;return this;&#125;&#125;obj.func; //obj void 一元运算符void 0 //undefined void(0) //undefined 运算符优先级 运算符 描述 . [] () 字段访问、数组下标、函数调用以及表达式分组 ++ -- - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 * / % 乘法、除法、取模 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 移位 == != === !== 等于、不等于、严格相等、非严格相等 &amp; 按位与 ^ 按位异或 丨 按位或 &amp;&amp; 逻辑与 丨丨 逻辑或 ?: 条件运算符 = oP= 赋值 , 逗号 语句block语句、var语句block 语句块语句常用于组合0 ~ 多个语句。块语句用一对花括号定义。没有块级的作用域，Java等很多语言都是有块级作用域的 12for(var i =0;i&lt;10;i++)&#123;&#125;i //10 但是JS有全局作用域、函数作用域等作用域 var 语句var a = b = 1 //这样写本身不会错，但是写在函数里面那么b将会是一个全局变量 try-catch三种表示形式（和Java一样） 123try&#123;&#125;catch(e)&#123;&#125;try&#123;&#125;finally&#123;&#125;try&#123;&#125;catch(e)&#123;&#125;finally&#123;&#125; 函数、switch、循环123function fd()&#123;&#125; //函数声明 var fe = function()&#123;&#125;; //函数表达式//fd() 会被函数前置，就是在fd（）函数声明代码之前调用也是可以的，表达式就不行 for…in 1for(var i in [1,2,3])&#123;&#125; 坑： 顺序不确定（依赖引擎实现） enumerable 为false时不会出现 for in 对象属性时受到原型链影响 with &lt;已经不建议使用了&gt;可以修改当前的作用域 123456789with(&#123;x:1&#125;)&#123; console.log(x);&#125;with(document.forms[0])&#123; console.log(name.value);&#125; ||var form = document.forms[0];console.log(form.name.value); 严格模式 严格模式是一种特殊的执行模式，它修复了部分语言上的不足，提供更强的错误检查，并增强安全性。是向上兼容的。 123function func()&#123; 'use strict'; //第一行&#125; 严格模式下不允许使用with 不允许为声明的变量被赋值 arguments变为参数的静态副本（与形参没有相互的绑定关系了，但是参数是对象去修改参数属性的话依旧会影响arguments[0].x = 100;） delete参数报错 对象字面量重复属性名报错 禁止八进制字面量 eval，arguments变为关键字，不能作为变量、函数名 eval变为独立作用域 对象对象中包含一系列属性，这些属性是无序的。每个属性都有一个字符串key和对应的value。每个对象还有一个原型，会有一个 [[ proto ]] 对象属性。还有[[class]]、[[extensible]] 对象中每一个属性都有很多标签（writeable、enumerable、configurable、value、get/set） 创建对象1234567891011121314151617181920212223var o = new Object;function foo()&#123;&#125; /*定义一个函数对象,这个函数对象会默认带一个prototype属性，它的属性是一个对象属性。(foo.prototype) 是一对象，每一个对象都有[[proto]]标签。这里的[[proto]] 指向-&gt; Object.prototype -&gt; null*/foo.prototype.z = 3; //往(foo.prototype) 对象中添加了一个属性 "z=3"var obj = new foo(); /*用new的方式构造了一个新对象，通过new这种方式构造对象的她点就是它的原型[[proto]]会指向构造器的prototype属性（foo.prototype），这么做的好处是可以访问原型链上的属性一直找到null*/obj.y = 2;obj.x = 1; //通过赋值操作，添加了两个属性给obj对象obj.x; //1obj.y; //2obj.z; //3typeof obj.toString; // 'function' toString 是 Object.prototype 中的'z' in obj; //trueobj.hasOwnProperty('z'); //falseobj.z = 5; /*赋值时，先看obj中有没有这个值，如果有的话就修改，没有的话就直接添加，不会去修改或者删除 foo.prototype 中的值。*/obj.z; // 5delete obj.z; //trueobj.z; //3delete obj.z; //trueobj.z; //3 , still 3! 通过 Object.create 创建对象 12345678var obj = Object.create(&#123;x:!&#125;);obj.x; //1obj.hasOwnProperty('z'); //false// 原型链 obj -&gt; &#123;x:1&#125; -&gt; Object.prototype -&gt; nullvar obj = Object.create(null);obj.toString //undefined// 原型链 obj -&gt; null 属性操作1234567891011121314var obj = &#123;x:1,y:2&#125;;obj.x; // 1 一般建议这种obj['y']; //2//in操作符 是会往原型链向上查找的for(var i in obj)&#123; //可能会把原型链上的属性遍历出来，顺序是不确定的 console.log(obj[i]); &#125;var i = 1 &amp;&amp; 2 &amp;&amp; 3; //i=3 巧用运算符，只有前面的值都存在时才会把最后一个值赋予var descriptor = Object.getOwnPropertyDescriptor(Obejct,'prototype');// 可以去获取一个属性中的所有标签，这里则是获取的Object对象的prototype属性的标签descriptor.configurable; //false 是否可配置 delete？ 需注意的是我们用对象自变量，new Obejct 去创建的对象，或者是通过赋值去创建这样的属性默认既可以枚举也可以写也可以delete，都是true的，而通过defineProperty这种方式创建的话默认都是false。 1234var cat = new Obejct;cat.propertyIsEnumerable('toString'); //false 是否可枚举的Obejct.defineProperty(cat,'price',&#123;enumerable:false,value:1000&#125;);cat.propertyIsEnumerable('price');//false 属性的枚举1234567891011121314151617var o = &#123;x : 1,y : 2&#125;;'toString' in o; //trueo.propertyIsEnumerable('toString'); //false var key;for(key in o)&#123; console.log(key); // x,y,z&#125;var obj = Object.create(o);obj.a = 4;var key;for(key in o)&#123; console.log(key); // a,x,y,z if(obj.hasOwnProperty(key))&#123; console.log(key); // a &#125;&#125; get/set方法123456789101112131415161718var man = &#123; name : 'A', $age: null, get age()&#123; return this.$age; &#125;, set age(val)&#123; val = +val; //转换为数字 if(!isNaN(val))&#123; this.$age = val; &#125;else&#123; throw new Error('Incorrent value'+val); &#125; &#125;&#125;man.age; // 自动调用get方法man.age = 100; //自动调用set方法 属性标签1234567891011121314151617181920212223242526272829303132333435363738394041424344Object.getOwnPropertyDescriptor(&#123;pro:true&#125;,'pro');// (对象，'属性名')查看属性标签/*&#123;…&#125; ​configurable: true //是否可以再被修改，被 delete ​enumerable: true //是否可被枚举 ​value: true ​writable: true //是否可写，修改 ​&lt;prototype&gt;: &#123;…&#125; ​​__defineGetter__: function __defineGetter__() ​​__defineSetter__: function __defineSetter__() ​​__lookupGetter__: function __lookupGetter__() ​​__lookupSetter__: function __lookupSetter__() ​​constructor: function Object() ​​hasOwnProperty: function hasOwnProperty() ​​isPrototypeOf: function isPrototypeOf() ​​propertyIsEnumerable: function propertyIsEnumerable() ​​toLocaleString: function toLocaleString() ​​toSource: function toSource() ​​toString: function toString() ​​valueOf: function valueOf()*///去创建管理这些属性var person = &#123;&#125;;Object.defineProperty(person,'name',&#123; configurable : true, ​enumerable : false, ​value : "Alen" ​writable : true&#125;);Object.keys(person); // [] 获取对象上的所有的key Object.defineProperties(person,&#123; title2:&#123;enumerable:true,value:"da"&#125;, salary:&#123;enumerable:true,value:50000,writable:true&#125;, promote:&#123;set:function(level)&#123; this.salary *= 1 + level*0.1; &#125;&#125;&#125;);Object.keys(person); // Array [ "title2", "salary" ]erson.salary; //50000person.promote = 2; //2person.salary; //60000 / configurable:true, writable:true configurable:true, writable:false configurable:false, writable:true configurable:false, writable:false 修改属性的值 ✔ ✔ 重设value标签修改 ✔ X 通过属性赋值修改属性值 ✔ X ✔ X delete 返回 true ✔ ✔ X X 修改getter/setter方法 ✔ ✔ X X 修改属性标签 （writable从true改为false总是运许） ✔ ✔ X X 对象标签、对象序列化[[proto]] [[class]] 表示对象是哪一个类型，Object.prototype.toString会把参数变为对象再做处理 1234var toString = Object.prototype.toString;function getType(o)&#123;return toString.call(o).slice(8,-1);&#125;toString.call(null); //"[object Null]"getType(null); //"Null" [[extensible]] 表示这个对像是否可扩展 12345678910var obj = &#123;x:1,y:2&#125;;Object.isExtensible(obj); // true 默认Object.preventExtensible(obj); Object.isExtensible(obj); //falseobj.z = 1;obj.z;//undefinedObject.seal(obj); // configurable -&gt;falseObject.isSealed(obj); //trueObject.freeze(obj); // writable -&gt; false configurable -&gt;falseObject.isFrozen(obj); //true 序列化1234567var obj = &#123;x:1,y:2,val:undefined,a:NaN,c:new Date()&#125;;JSON.stringify(obj); // "&#123;\"x\":1,\"y\":2,\"a\":null,\"c\":\"2018-07-27T06:37:28.989Z\"&#125;"//JSON.stringify 如果属性中有undefined，那么这个值将不会被转化，NaN -&gt;null obj = JSON.parse('&#123;"x":1&#125;'); //注意合法的JSON 属性名必须用双引号obj.x; //1 序列化-自定义 12var obj = &#123;x:1,o:&#123;o1:1,o2:2,toJSON:function()&#123;return this.o1+this.o2&#125;&#125;&#125;;JSON.stringify(obj);// "&#123;\"x\":1,\"o\":3&#125;" 其它对象方法1234567891011var obj = &#123;x:1,y:2&#125;;obj.toString(); // "[object Object]""Result"+obj; // "Result[object Object]"obj.toString = function()&#123;return this.x+this.y&#125;; //重写toString方法"Result"+obj; // "Result3"+obj; // 3obj.valueOf = function()&#123;return this.x+this.y+100&#125;; //尝试把对象转为基本类型时候调用的函数+obj; // 103"Result"+obj; // "Result103" 当valueOf 和 toString都存在时 拼接和 + 时，都会尝试把对象转化为基本类型，会先去valueOf 若返回的是对象则会去找toString]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>视频笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想笔记（一）]]></title>
    <url>%2F2018%2F07%2F25%2Fjava-bcsx-note-1%2F</url>
    <content type="text"><![CDATA[记录《Thinking in Java》一书的笔记 初始化与清理this当发送消息给对象时，编译器做了一些幕后工作。它暗自把“所操作对象的引用”作为第一个参数传递给该对象调用的方法。 12FuncClass.method(funcObj1,args1);FuncClass.method(funcObj2,args2); 由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：this。 this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。用法和对象的引用一样。但要注意如果在方法的内部调用同类的另一个方法，就不必使用this，直接调用即可，编译器会自动帮你添加。 只有当需要明确指出对当前对象的引用时，才需要使用this关键字 例如，当需要返回当前对象的引用时，就常常在return语句中这样写 1return this; this关键字对于将当前对象传递给其他方法也很有用 123456789101112131415class Person&#123; public void eat(Apple apple)&#123; Apple peeled = apple.getPeeled(); &#125;&#125;class Peeler&#123; static Apple peel(Apple apple)&#123; return apple; &#125;&#125;class Apple&#123; Apple getPeeled()&#123; return Peeler.peel(this); &#125;&#125; Apple需要调用Peeler.peel()方法，它是一个外部的工具方法，为了将自身传递给外部方法，Apple必须使用this关键字。 this 还可用于在构造器中调用构造器，但只能调用一个且必须将其调用置于最起始处，否则编译器报错。 static方法没有this关键字。 清理1.对象可能不被垃圾回收。2.垃圾回收并不等于“析构”。 finalize()的用途何在？一旦GC准备好释放对象占用的内存，将首先调用finalize()方法，并且下次GC动作发生时，才会真正回收对象占用内存，3.垃圾回收只与内存有关。之所以要有finalize()，是由于在分配内存时可能采用类C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其它语言写的代码，所以实际上可以调用任何代码。在非Java代码中，也许会调用C的malloc()函数系列来分配存储空间，而且除非调用free()函数，否则存储空间将得不到释放，从而造成内存泄漏。当然free()是C和C++中的函数，所以需在finalize()中用本地方法调用它。*所以它确实不是进行普通清理工作使用的。而且绝对不能直接调用finalize()，但可以用于验证终结条件以发现程序缺陷 * 垃圾回收（GC）器如何工作？存储空间的释放会影响存储空间的分配。堆的实现像是一个传送带，没分配一个新对象，它就往前移动一格。当创建足够多的对象后，内存资源将耗尽，GC介入,它一边回收空间，一边使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传送带的开始处，也避免了页面错误（频繁的内存页面调度）。 GC机制 引用记数常用于来说明垃圾收集的工作方式，但似乎从未被应用于任何一种JVM。 它的依据思想是：对任何“活”的对象，一定能最终追溯到其存活在堆栈和静态存储区之中的引用，这个引用链条可能会穿过数个对象层次。在这种方式下，JVM将采用一种自适应的垃圾回收技术。实现取决于不同的JVM的实现。 “自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。 构造器初始化初始化顺序 在类的内部，变量定义的先后决定了初始化的顺序，即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。 静态数据初始化 书中写到构造器实际上也是静态方法，似乎是有点问题的。以下测试代码和解释出自-&gt; 实例构造器是不是静态方法？ 举个例子，下面的Java代码 1234567891011public class ConstructorDemo &#123; private int value; public ConstructorDemo(int i, Object o) &#123; this.value = i; &#125; public static void main(String[] args) &#123; ConstructorDemo demo = new ConstructorDemo(2, args); &#125; &#125; 被编译为class文件后，实例构造器与main()方法的内容分别为： 1234567891011121314151617181920public ConstructorDemo(int, java.lang.Object); Code: Stack=2, Locals=3, Args_size=3 0: aload_0 1: invokespecial #1; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: iload_1 6: putfield #2; //Field value:I 9: return public static void main(java.lang.String[]); Code: Stack=4, Locals=2, Args_size=1 0: new #3; //class ConstructorDemo 3: dup 4: iconst_2 5: aload_0 6: invokespecial #4; //Method &quot;&lt;init&gt;&quot;:(ILjava/lang/Object;)V 9: astore_1 10: return 先从main()方法开始看。第一条指令是new，用于创建出ConstructorDemo类型的一个空对象，执行过后指向该对象的引用被压到操作数栈上。第二条指令是dup，将操作数栈顶的值复制一份压回到栈顶；其中dup出来的一份用于作为隐式参数传到实例构造器里去（对应后面的invokespecial），原本的一份用于保存到局部变量去（对应后面的astore_1）。第三条指令是iconst_2，将常量2压到操作数栈上，作为ConstructorDemo实例构造器的第一个显式参数。第四条指令是aload_0，将main()方法的参数args作为ConstructorDemo实例构造器的第二个显式参数。第五条指令是invokespecial，调用ConstructorDemo实例构造器。再次留意，前面已经传了三个参数，分别是new出来的实例的引用、常量2与main()的参数args。该指令执行过后，操作数栈顶就只剩下dup前通过new得到的引用。第6条指令是astore_1，将操作数栈顶的引用保存到局部变量1中。执行过后操作数栈空了。最后一条指令是return，结束main()方法的执行并返回。 然后从ConstructorDemo的实例构造器来看。第一条指令是aload_0，将第一个参数（不管是隐式还是显式参数）压到操作数栈上。从main()的调用序列可以看到第一个参数是刚new出来的对象实例的引用，对这个构造器来说也就是“this”。第二条指令是invokespecial，调用Object的实例构造器。前一条指令的“this”就是这个调用的参数。执行过后操作数栈就空了。第三条指令又是aload_0，再次将“this”压到操作数栈上。第四条指令是iload_1，将第二个参数压到操作数栈上，也就是i。第五条指令是putfield，将i赋值给this.value。执行过后操作数栈又空了。最后一条指令是return，结束该实例构造器的执行并返回。 这个例子的注意点在于：1、Java的实例构造器只负责初始化，不负责创建对象；Java虚拟机的字节码指令的设计也反映了这一点，有一个new指令专门用于创建对象实例，而调用实例构造器则使用invokespecial指令。2、“this”是作为实例构造器的第一个实际参数传入的。 Java虚拟机规范第二版中定义了四种不同的字节码指令来处理Java程序中不同种类的方法的调用：· invokestatic - 用于调用类（静态）方法· invokespecial - 用于调用实例方法，特化于super方法调用、private方法调用与构造器调用· invokevirtual - 用于调用一般实例方法（包括声明为final但不为private的实例方法）· invokeinterface - 用于调用接口方法 可变参数列表12345678910static void print(Object...objects)&#123; for (Object object : objects) &#123; System.out.println(object); &#125;&#125;static void print(int i ,Integer...integers)&#123; for (Object integer : integers) &#123; System.out.println(integer); &#125;&#125; 你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不用它。 枚举枚举类型的实例是常量，因此惯例它们都用大写字母表示(有多个单词用下划线隔开)，为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例DemoEnum d = DemoEnum.DEMO,创建enum时编译器会自动添加一些有用的特性，如，toString()，ordinal()&lt;表示某个特定enum常量的声明顺序&gt;，static values()&lt;按照enum常量声明顺序生成数组&gt;。事实上enum确实是类，并且具有自己的方法。它与switch语句是绝佳的组合]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>书籍笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F07%2F24%2Fmarkdown-note%2F</url>
    <content type="text"><![CDATA[##标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 ##字体 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ ##引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个… 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 ##分割线三个或者三个以上的 - 或者 * 都可以。 1234-------******** ##图片语法： 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ##超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 ##列表 无序列表 有序列表 语法： 数字加点 1234567891011- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格1.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 ##表格 语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 表头 表头 表头 内容 内容 内容 内容 内容 内容 ##代码 语法： 123单行代码 `代码内容`多行代码 代码内容 123456789101112```***##流程图```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;]]></content>
      <categories>
        <category>Markdown教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo笔记]]></title>
    <url>%2F2018%2F07%2F16%2Fhexo-note%2F</url>
    <content type="text"><![CDATA[hexo clean //清除缓存hexo g //重新生成代码hexo s //部署到本地 //然后打开浏览器访问 localhost:4000 查看效果 依次执行以下命令：清理 – 生成 – 部署github 123$ hexo clean$ hexo generate$ hexo deploy ##git push &amp; git pull 推送/拉取分支git push 使用本地的对应分支来更新对应的远程分支。 如果在github的remote上已经有了文件，会出现错误。此时应当先pull一下，即：git pull 获取并合并其他的仓库，或者本地的其他分支。 12$ git pull origin (master/hexo)$ git push origin (master/hexo) 博客管理流程1.创建两个分支：master 与 hexo； 2.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 3.使用git clone git@github.com:GitName/GitName.github.io.git拷贝仓库； 4.在本地GitName.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init 、npm install和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 5.修改_config.yml中的deploy参数，分支应为master； 6.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 7.执行hexo generate -d生成网站并部署到GitHub上。这样一来，在GitHub上的GitName.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 日常修改在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 2.然后才执行hexo generate -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 1.使用git clone git@github.com:GitName/GitName.github.io.git拷贝仓库（默认分支为hexo）； 2.在本地新拷贝的GitName.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[博客搭建网址合集]]></title>
    <url>%2F2018%2F06%2F17%2Fblog-build-url%2F</url>
    <content type="text"><![CDATA[Hexo NexT 使用Hexo+Github一步步搭建属于自己的博客（基础） 创建Git分支将Hexo博客迁移到其它电脑 Hexo博客优化加载速度 hexo的next主题个性化教程 搭建Hexo博客（Next主题） Hexo NexT主题中集成gitalk]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
